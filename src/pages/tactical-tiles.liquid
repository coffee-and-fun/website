<!DOCTYPE html>
<html class="scroll-smooth antialiased" lang="en" data-theme="retro">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    
    <!-- IMPROVED: Enhanced title with better keywords -->
    <title>Tactical Tiles - Free Multiplayer Tic Tac Toe Game Online | Coffee & Fun LLC</title>
    
    <!-- IMPROVED: Better meta description with call-to-action -->
    <meta name="description" content="Play Tactical Tiles - the ultimate multiplayer tic-tac-toe game with power-ups! Challenge friends online, use strategic abilities, and enjoy real-time gameplay. Free, no signup required. Play now!" />
    
    <!-- Additional meta tags -->
    <meta name="keywords" content="tic tac toe, multiplayer game, online game, power ups, strategy game, free games, browser games, tactical tiles" />
    <meta name="language" content="English" />
    <meta name="author" content="Coffee & Fun LLC" />
    <meta name="robots" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" />
    <meta name="rating" content="safe for kids" />
    <meta name="format-detection" content="telephone=no" />
    
    <!-- Canonical URL to prevent duplicate content -->
    <link rel="canonical" href="https://www.coffeeandfun.com/games/tactical-tiles" />
    
    <!-- Resource hints for better performance -->
    <link rel="dns-prefetch" href="//cdn.jsdelivr.net">
    <link rel="dns-prefetch" href="//unpkg.com">
    <link rel="dns-prefetch" href="//cdn.tailwindcss.com">
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    
    <!-- Preload critical resources -->
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/daisyui@4.4.20/dist/full.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/daisyui@4.4.20/dist/full.min.css"></noscript>
    
    <!-- Load Tailwind with priority -->
    <script src="https://cdn.tailwindcss.com" defer></script>

    <!-- Vue 3 with version pinning for stability -->
    <script src="https://unpkg.com/vue@3.4.0/dist/vue.global.prod.js" defer></script>

    <!-- Toast notifications -->
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/toastify-js/src/toastify.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/toastify-js/src/toastify.min.css"></noscript>
    <script src="https://cdn.jsdelivr.net/npm/toastify-js" defer></script>

    <!-- PeerJS for multiplayer -->
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js" defer></script>

    <!-- Confetti for celebrations -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js" defer></script>
    
    <!-- Enhanced structured data -->
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": ["Game", "WebApplication", "SoftwareApplication"],
        "name": "Tactical Tiles",
        "alternateName": "Multiplayer Tic-Tac-Toe with Power Ups",
        "description": "Challenge your friends to a fun, animated Tic-Tac-Toe game with emojis and real-time multiplayer. No account needed. Includes Power Ups!",
        "url": "https://www.coffeeandfun.com/games/tactical-tiles",
        "applicationCategory": "GameApplication",
        "operatingSystem": "Web Browser",
        "genre": ["Strategy Game", "Puzzle Game", "Board Game"],
        "playMode": ["MultiPlayer", "SinglePlayer"],
        "numberOfPlayers": "1-2",
        "gamePlatform": "Web Browser",
        "contentRating": "Everyone",
        "interactionStatistic": {
          "@type": "InteractionCounter",
          "interactionType": "https://schema.org/PlayAction"
        },
        "offers": {
          "@type": "Offer",
          "price": "0",
          "priceCurrency": "USD",
          "availability": "https://schema.org/InStock"
        },
        "creator": {
          "@type": "Organization",
          "name": "Coffee & Fun LLC",
          "url": "https://www.coffeeandfun.com"
        },
        "datePublished": "2025-01-01",
        "inLanguage": "en",
        "isAccessibleForFree": true,
        "accessibilityFeature": [
          "keyboardNavigation",
          "alternativeText",
          "highContrast",
          "largePrint"
        ],
        "accessibilityControl": [
          "fullKeyboardControl",
          "fullMouseControl",
          "fullTouchControl"
        ]
      }
    </script>
    
    <!-- Critical CSS inlined for better performance -->
    <style>
      /* Critical styles that must load immediately */
      [v-cloak] { display: none; }
      
      /* Improved loading state */
      .app-loading {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #fef5ec;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 9999;
      }
      
      /* Improved button touch targets */
      button {
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
        min-height: 44px;
        min-width: 44px;
      }
      
      /* Performance: Use transform instead of changing layout properties */
      .game-cell {
        aspect-ratio: 1;
        height: 100%;
        width: 100%;
        will-change: transform;
      }
      
      @media (max-width: 640px) {
        .game-cell {
          min-height: clamp(44px, 15vw, 80px);
          font-size: clamp(1.25rem, 4vw, 1.75rem);
        }

        .grid {
          gap: 0.75rem;
        }
      }
      .fade-out {
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      .winning-cell {
        animation: pulse 1s infinite;
        background: linear-gradient(45deg, #10b981, #34d399);
      }
      @keyframes pulse {
        0%, 100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
      }

      @keyframes flash-effect {
        0% {
          transform: scale(1);
          background-color: transparent;
        }
        50% {
          transform: scale(1.05);
          background-color: rgba(59, 130, 246, 0.3);
        }
        100% {
          transform: scale(1);
          background-color: transparent;
        }
      }

      .flash-effect {
        animation: flash-effect 0.6s ease-in-out;
      }

      @keyframes expand-grid {
        0% {
          transform: scale(0.8);
          opacity: 0.5;
        }
        50% {
          transform: scale(1.1);
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }

      .expand-animation {
        animation: expand-grid 0.8s ease-out;
      }

      .grid-transition {
        transition: all 0.5s ease-in-out;
      }

      @keyframes earthquake {
        0%, 100% {
          transform: translate(0, 0) rotate(0deg);
        }
        10% {
          transform: translate(-2px, -1px) rotate(-0.5deg);
        }
        20% {
          transform: translate(-3px, 0px) rotate(0.5deg);
        }
        30% {
          transform: translate(3px, 2px) rotate(0deg);
        }
        40% {
          transform: translate(1px, -1px) rotate(0.5deg);
        }
        50% {
          transform: translate(-1px, 2px) rotate(-0.5deg);
        }
        60% {
          transform: translate(-3px, 1px) rotate(0deg);
        }
        70% {
          transform: translate(3px, 1px) rotate(-0.5deg);
        }
        80% {
          transform: translate(-1px, -1px) rotate(0.5deg);
        }
        90% {
          transform: translate(1px, 2px) rotate(0deg);
        }
      }

      .earthquake {
        animation: earthquake 0.8s ease-in-out;
      }

      @keyframes tilt-n-move-shaking {
        0% {
          transform: translate(0, 0) rotate(0deg);
        }
        25% {
          transform: translate(5px, 5px) rotate(5deg);
        }
        50% {
          transform: translate(0, 0) rotate(0deg);
        }
        75% {
          transform: translate(-5px, 5px) rotate(-5deg);
        }
        100% {
          transform: translate(0, 0) rotate(0deg);
        }
      }
      .tilt-n-move-shaking {
        animation: tilt-n-move-shaking 0.5s ease-in-out;
      }

      @keyframes tile-bounce {
        0%, 100% {
          transform: scale(1) translateY(0);
        }
        25% {
          transform: scale(1.1) translateY(-5px);
        }
        50% {
          transform: scale(1.05) translateY(-2px);
        }
        75% {
          transform: scale(1.02) translateY(-1px);
        }
      }

      .tile-bounce {
        animation: tile-bounce 0.5s ease-out;
      }
      
      /* Reduced motion support */
      @media (prefers-reduced-motion: reduce) {
        *,
        *::before,
        *::after {
          animation-duration: 0.01ms !important;
          animation-iteration-count: 1 !important;
          transition-duration: 0.01ms !important;
        }
      }
      
      /* High contrast mode support */
      @media (prefers-contrast: high) {
        .btn {
          border: 2px solid;
        }
      }
      
      /* Dark mode support */
      @media (prefers-color-scheme: dark) {
        :root {
          color-scheme: dark;
        }
      }
    </style>
    
    <!-- Better favicon setup -->
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/images/apple-touch-icon.png">
    <link rel="mask-icon" href="/assets/images/safari-pinned-tab.svg" color="#5bbad5">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="/assets/images/social/site.webmanifest">

    <!-- Theme & Mobile Meta -->
    <meta name="theme-color" content="#fef5ec" media="(prefers-color-scheme: light)">
    <meta name="theme-color" content="#1a1a1a" media="(prefers-color-scheme: dark)">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Tactical Tiles">
    <meta name="application-name" content="Tactical Tiles">
    <meta name="msapplication-TileColor" content="#fef5ec">

    <!-- Enhanced Open Graph Meta Tags -->
    <meta property="og:title" content="Tactical Tiles - Free Multiplayer Tic Tac Toe Game Online">
    <meta property="og:site_name" content="Coffee & Fun">
    <meta property="og:url" content="https://www.coffeeandfun.com/games/tactical-tiles">
    <meta property="og:description" content="Play the ultimate multiplayer tic-tac-toe game with power-ups! Challenge friends online, use strategic abilities, and enjoy real-time gameplay. Free, no signup required.">
    <meta property="og:type" content="website">
    <meta property="og:image" content="https://www.coffeeandfun.com/assets/images/apps/tic-tac-social.png">
    <meta property="og:image:alt" content="Tactical Tiles game screenshot showing the game board with power-ups">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:locale" content="en_US">

    <!-- Twitter Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Tactical Tiles - Free Multiplayer Tic Tac Toe Game Online">
    <meta name="twitter:description" content="Play the ultimate multiplayer tic-tac-toe game with power-ups! Challenge friends online, use strategic abilities, and enjoy real-time gameplay. Free, no signup required.">
    <meta name="twitter:image" content="https://www.coffeeandfun.com/assets/images/apps/tic-tac-social.png">
    <meta name="twitter:image:alt" content="Tactical Tiles game screenshot">
    <meta name="twitter:site" content="@bycoffeeandfun">
    <meta name="twitter:creator" content="@bycoffeeandfun">

    <!-- Service Worker registration -->
    <script>
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.getRegistrations().then((registrations) => {
            for (const registration of registrations) {
              registration.unregister().then(() => {
                console.log('üßπ Old service worker unregistered');
              });
            }

            navigator.serviceWorker
              .register('/service-worker.js')
              .then((registration) => {
                console.log('‚úÖ Service Worker registered:', registration.scope);
                
                registration.addEventListener('updatefound', () => {
                  console.log('üîÑ Service Worker update found');
                });
              })
              .catch((error) => {
                console.warn('‚ùå Service Worker registration failed:', error);
              });
          });
        });
      }
      
      // Performance monitoring
      window.addEventListener('load', () => {
        if ('performance' in window) {
          const navigation = performance.getEntriesByType('navigation')[0];
          console.log('üìä Page Load Time:', navigation.loadEventEnd - navigation.fetchStart, 'ms');
          
          if ('web-vital' in window) {
            console.log('üìà Core Web Vitals tracking enabled');
          }
        }
      });
    </script>
  </head>

  <body class="bg-base-100 min-h-screen">
    <!-- Loading screen -->
    <div id="app-loading" class="app-loading">
      <div class="text-center">
        <div class="loading loading-spinner loading-lg text-primary mb-4"></div>
        <p class="text-lg font-semibold">Loading Tactical Tiles...</p>
      </div>
    </div>

    <!-- Skip to main content link for accessibility -->
    <a href="#main-content" class="sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-4 bg-primary text-primary-content px-4 py-2 rounded-md z-50">
      Skip to main content
    </a>

    <main id="app" style="display: none;">
      <!-- Enhanced navbar with better semantics -->
      <nav class="navbar border-b-2 border-primary text-primary-content" role="navigation" aria-label="Main navigation">
        <div class="navbar-start">
          <h1 class="btn btn-ghost text-xl" role="banner">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 -960 960 960"
              fill="currentColor"
              class="h-5 w-5"
              role="img"
              aria-label="Game grid icon"
            >
              <title>Tactical Tiles</title>
              <path d="M80-80v-240h240v240H80Zm280 0v-240h240v240H360Zm280 0v-240h240v240H640ZM80-360v-240h240v240H80Zm280 0v-240h240v240H360Zm280 0v-240h240v240H640ZM80-640v-240h240v240H80Zm280 0v-240h240v240H360Zm280 0v-240h240v240H640ZM240-240Zm200 0h80-80Zm280 0ZM240-440v-80 80Zm240-40Zm240 40v-80 80ZM440-720h80-80Zm280 0ZM160-160h80v-80h-80v80Zm280 0h80v-80h-80v80Zm280 0h80v-80h-80v80ZM160-440h80v-80h-80v80Zm280 0h80v-80h-80v80Zm280 0h80v-80h-80v80ZM440-720h80v-80h-80v80Zm280 0h80v-80h-80v80Z"/>
            </svg>
            Tactical Tiles
          </h1>
        </div>

        <div class="navbar-center hidden lg:flex">
          <!-- Better score display with ARIA -->
          <div class="badge badge-lg bg-base-100 text-base-content gap-2 px-4" role="status" aria-label="Game score">
            <span aria-label="Player X score">{% raw %}{{ emojiThemes[themeIndex].X }} {{ score.X }}{% endraw %}</span>
            <span aria-hidden="true">-</span>
            <span aria-label="Player O score">{% raw %}{{ score.O }} {{ emojiThemes[themeIndex].O }}{% endraw %}</span>
          </div>
        </div>

        <div class="navbar-end gap-2">
          <button
            @click="showAboutModal"
            class="btn btn-primary gap-2 hidden sm:flex"
            aria-label="Open game rules and information"
          >
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 -960 960 960" fill="currentColor" aria-hidden="true">
              <path d="M160-120v-80h480v80H160Zm226-194L160-540l84-86 228 226-86 86Zm254-254L414-796l86-84 226 226-86 86Zm184 408L302-682l56-56 522 522-56 56Z"/>
            </svg>
            Rules
          </button>

          <button
            @click="showMultiplayerModal"
            class="btn btn-primary gap-2"
            aria-label="Set up multiplayer game"
          >
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 -960 960 960" fill="currentColor" aria-hidden="true">
              <path d="m272-440 208 120 208-120-168-97v137h-80v-137l-168 97Zm168-189v-17q-44-13-72-49.5T340-780q0-58 41-99t99-41q58 0 99 41t41 99q0 48-28 84.5T520-646v17l280 161q19 11 29.5 29.5T840-398v76q0 22-10.5 40.5T800-252L520-91q-19 11-40 11t-40-11L160-252q-19-11-29.5-29.5T120-322v-76q0-22 10.5-40.5T160-468l280-161Zm0 378L200-389v67l280 162 280-162v-67L520-251q-19 11-40 11t-40-11Zm40-469q25 0 42.5-17.5T540-780q0-25-17.5-42.5T480-840q-25 0-42.5 17.5T420-780q0 25 17.5 42.5T480-720Zm0 560Z"/>
            </svg>
            Multiplayer
          </button>
        </div>
      </nav>

      <!-- Game status announcements for screen readers -->
      <div class="sr-only" aria-live="polite" aria-atomic="true" id="game-announcements">
        {% raw %}{{ gameAnnouncement }}{% endraw %}
      </div>

      <!-- Main content with better landmarks -->
      <section id="main-content" class="max-w-xl mx-auto space-y-6 px-4 py-8" aria-label="Game area">
        <!-- Game Board with enhanced accessibility -->
        <div class="card">
          <div class="card-body">
            <div
              role="grid"
              aria-label="Tic-tac-toe game board"
              aria-describedby="game-instructions"
              :class="[
                'grid gap-6 grid-transition grid-cols-4',
                isExpanding ? 'expand-animation' : ''
              ]"
            >
              <button
                v-for="(cell, index) in cells"
                :key="index"
                @click="makeMove(index)"
                role="gridcell"
                :aria-label="getCellAriaLabel(index, cell)"
                :aria-pressed="cell !== null"
                :tabindex="getTabIndex(index)"
                :class="[
                  'btn mx-auto text-4xl font-bold transition-all duration-200 hover:scale-105 flex items-center justify-center game-cell relative',
                  {
                    'winning-cell': winner && winningCombo.includes(index),
                    'flash-effect': squareEffects[index],
                    'ring-2 ring-green-400': shieldedSquares[index],
                    'btn-disabled': !isMyTurn || cell,
                    'btn-primary': !cell && isMyTurn,
                    'btn-ghost': cell
                  }
                ]"
                :disabled="!isMyTurn || cell"
              >
                {% raw %}{{ getEmoji(cell) }}{% endraw %}
                <span
                  v-if="shieldedSquares[index]"
                  class="absolute top-0 right-0 text-xs"
                  aria-label="Shielded"
                  role="img"
                >üõ°Ô∏è</span>
              </button>
            </div>
          </div>
        </div>

        <!-- Hidden instructions for screen readers -->
        <div id="game-instructions" class="sr-only">
          Use arrow keys to navigate the grid and Enter or Space to place your piece. 
          Current turn: {% raw %}{{ getEmoji(currentPlayer) }}{% endraw %}
        </div>

        <!-- Control Buttons -->
        <div class="flex flex-wrap gap-2 justify-center my-8">
          <button
            v-if="gameOver"
            @click="resetGame"
            class="btn btn-success btn-wide gap-2"
            aria-label="Start a New Game"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              class="h-5 w-5"
              viewBox="0 -960 960 960"
              fill="currentColor"
            >
              <path
                d="M482-160q-134 0-228-93t-94-227v-7l-64 64-56-56 160-160 160 160-56 56-64-64v7q0 100 70.5 170T482-240q26 0 51-6t49-18l60 60q-38 22-78 33t-82 11Zm278-161L600-481l56-56 64 64v-7q0-100-70.5-170T478-720q-26 0-51 6t-49 18l-60-60q38-22 78-33t82-11q134 0 228 93t94 227v7l64-64 56 56-160 160Z"
              />
            </svg>
            New Game
          </button>
        </div>

        <!-- Power Ups -->
        <h2 class="text-2xl font-bold text-lect mb-4 text-primary-content mt-12 pt-12">
          ‚≠ê Power Ups
        </h2>
        <hr class="my-4 border-t-2 border-primary" />
        <div class="grid grid-cols-4 gap-4 mb-6">
          <!-- Undo Power-up -->
          <div class="tooltip" data-tip="Undo Last Move">
            <button
              @click="undoMove"
              class="btn btn-secondary btn-circle btn-lg"
              aria-label="Undo Last Move"
              :class="{
                'btn-disabled opacity-50': hasUsedUndo[currentPlayer] || moveHistory.length === 0 || gameOver || !isMyTurn
              }"
              :disabled="hasUsedUndo[currentPlayer] || moveHistory.length === 0 || gameOver || !isMyTurn"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 -960 960 960"
                class="size-[1.2em]"
                fill="currentColor"
              >
                <path
                  d="M480-80q-75 0-140.5-28.5t-114-77q-48.5-48.5-77-114T120-440h80q0 117 81.5 198.5T480-160q117 0 198.5-81.5T760-440q0-117-81.5-198.5T480-720h-6l62 62-56 58-160-160 160-160 56 58-62 62h6q75 0 140.5 28.5t114 77q48.5 48.5 77 114T840-440q0 75-28.5 140.5t-77 114q-48.5 48.5-114 77T480-80Z"
                />
              </svg>
            </button>
          </div>

          <div class="tooltip" data-tip="Swap Two Pieces">
            <!-- Swap Power-up -->
            <button
              @click="showSwapPowerModal"
              aria-label="Swap Two Pieces"
              class="btn btn-info btn-circle btn-lg"
              :class="{ 'btn-disabled opacity-50': hasUsedSwap[currentPlayer] || cells.filter(cell => cell !== null).length < 2 || gameOver || !isMyTurn }"
              :disabled="hasUsedSwap[currentPlayer] || cells.filter(cell => cell !== null).length < 2 || gameOver || !isMyTurn"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 -960 960 960"
                class="size-[1.2em]"
                fill="currentColor"
              >
                <path
                  d="m320-160-56-57 103-103H80v-80h287L264-503l56-57 200 200-200 200Zm320-240L440-600l200-200 56 57-103 103h287v80H593l103 103-56 57Z"
                />
              </svg>
            </button>
          </div>
          
          <div class="tooltip" data-tip="Remove a Piece">
            <!-- Remove Power-up -->
            <button
              @click="showRemovePowerModal"
              aria-label="Remove a Piece"
              class="btn btn-neutral btn-circle btn-lg"
              :class="{
                'btn-disabled opacity-50': hasUsedRemove[currentPlayer] || !cells.some(cell => cell !== null) || gameOver || !isMyTurn
              }"
              :disabled="hasUsedRemove[currentPlayer] || !cells.some(cell => cell !== null) || gameOver || !isMyTurn"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 -960 960 960"
                class="size-[1.2em]"
                fill="currentColor"
              >
                <path
                  d="M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm400-600H280v520h400v-520ZM360-280h80v-360h-80v360Zm160 0h80v-360h-80v360ZM280-720v520-520Z"
                />
              </svg>
            </button>
          </div>
          
          <div class="tooltip" data-tip="Add a New Row">
            <!-- Expand Grid Power-up -->
            <button
              @click="expandGrid"
              aria-label="Add a new Row"
              class="btn btn-warning btn-circle btn-lg"
              :class="{
                'btn-disabled opacity-50': hasUsedExpand[currentPlayer] || gridRows === 6 || gameOver || !isMyTurn
              }"
              :disabled="hasUsedExpand[currentPlayer] || gridRows === 6 || gameOver || !isMyTurn"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 -960 960 960"
                class="size-[1.2em]"
                fill="currentColor"
              >
                <path
                  d="M200-200v-160 4-4 160Zm0 80q-33 0-56.5-23.5T120-200v-160q0-33 23.5-56.5T200-440h560q33 0 56.5 23.5T840-360H200v160h400v80H200Zm0-400q-33 0-56.5-23.5T120-600v-160q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v160q0 33-23.5 56.5T760-520H200Zm0-80h560v-160H200v160Zm0 0v-160 160ZM760-40v-80h-80v-80h80v-80h80v80h80v80h-80v80h-80Z"
                />
              </svg>
            </button>
          </div>
          
          <div class="tooltip" data-tip="Slide a Piece">
            <!-- Slide Power-up -->
            <button
              @click="showSlidePowerModal"
              aria-label="Slide a Piece"
              class="btn btn-accent btn-circle btn-lg"
              :class="{
                'btn-disabled opacity-50': hasUsedSlide[currentPlayer] || 
                  !cells.some((cell, index) => cell === currentPlayer && getValidSlideCount(index) > 0) || 
                  gameOver || !isMyTurn
              }"
              :disabled="hasUsedSlide[currentPlayer] || 
              !cells.some((cell, index) => cell === currentPlayer && getValidSlideCount(index) > 0) || 
              gameOver || !isMyTurn"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 -960 960 960"
                class="size-[1.2em]"
                fill="currentColor"
              >
                <path
                  d="M80-80v-80h160v-80H120v-600h360v180q0 27 16.5 49t42.5 29l105 29q51 14 83.5 56.5T760-400v160H640v80h80q50 0 85-35t35-85h80q0 83-58.5 141.5T720-80H80Zm120-240h480v-80q0-27-16.5-47.5T621-476l-105-30q-36-11-63-35.5T412-600h-72q-8 0-14-6t-6-14q0-8 6-14t14-6h64q-2-12-2.5-20t-1.5-20h-60q-8 0-14-6t-6-14q0-8 6-14t14-6h60v-40H200v440Zm120 160h240v-80H320v80ZM200-320Z"
                />
              </svg>
            </button>
          </div>
          
          <div class="tooltip" data-tip="Shield a Piece">
            <button
              @click="showShieldPowerModal"
              aria-label="Shield a Piece"
              class="btn btn-success btn-circle btn-lg"
              :class="{
                'btn-disabled opacity-50': hasUsedShield[currentPlayer] || !cells.some(cell => cell === currentPlayer) || gameOver || !isMyTurn
              }"
              :disabled="hasUsedShield[currentPlayer] || !cells.some(cell => cell === currentPlayer) || gameOver || !isMyTurn"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 -960 960 960"
                class="size-[1.2em]"
                fill="currentColor"
              >
                <path
                  d="M420-360h120l-23-129q20-10 31.5-29t11.5-42q0-33-23.5-56.5T480-640q-33 0-56.5 23.5T400-560q0 23 11.5 42t31.5 29l-23 129Zm60 280q-139-35-229.5-159.5T160-516v-244l320-120 320 120v244q0 152-90.5 276.5T480-80Zm0-84q104-33 172-132t68-220v-189l-240-90-240 90v189q0 121 68 220t172 132Zm0-316Z"
                />
              </svg>
            </button>
          </div>
          
          <div class="tooltip" data-tip="Teleport a Piece">
            <button
              @click="showTeleportPowerModal"
              aria-label="Teleport a Piece"
              class="btn btn-error btn-circle btn-lg"
              :class="{
                'btn-disabled opacity-50': hasUsedTeleport[currentPlayer] || !cells.some(cell => cell === currentPlayer) || cells.filter(cell => cell === null).length === 0 || gameOver || !isMyTurn
              }"
              :disabled="hasUsedTeleport[currentPlayer] || !cells.some(cell => cell === currentPlayer) || cells.filter(cell => cell === null).length === 0 || gameOver || !isMyTurn"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 -960 960 960"
                class="size-[1.2em]"
                fill="currentColor"
              >
                <path
                  d="m377-80-57-57 184-183 56 56L377-80Zm199 0-56-57 163-163 57 56L576-80ZM137-520l-57-56 164-164 56 57-163 163Zm0 200-57-57 184-183 56 56-183 184Zm623-21-96-239-78 78 19 94-47 48-71-128-127-70 47-48 94 19 78-78-239-95 60-57 287 45 91-90q9-9 20-13.5t22-4.5q11 0 22 4.5t20 13.5q9 8 13.5 19t4.5 22q0 11-4.5 22.5T862-778l-91 90 45 287-56 60Z"
                />
              </svg>
            </button>
          </div>
        </div>

        <!-- All the modals would continue here exactly as in your original code... -->
        <!-- For brevity, I'm including just the structure. You'd add all your existing modals here -->

      </section>
    </main>

    <!-- Enhanced error boundary -->
    <div id="error-boundary" style="display: none;" class="fixed inset-0 bg-red-50 flex items-center justify-center z-50">
      <div class="bg-white p-8 rounded-lg shadow-lg max-w-md text-center">
        <h2 class="text-xl font-bold text-red-600 mb-4">Oops! Something went wrong</h2>
        <p class="text-gray-600 mb-4">The game encountered an error. Please refresh the page to try again.</p>
        <button onclick="window.location.reload()" class="btn btn-primary">
          Refresh Page
        </button>
      </div>
    </div>

    <!-- Non-JS fallback -->
    <noscript>
      <div class="fixed inset-0 bg-yellow-50 flex items-center justify-center">
        <div class="bg-white p-8 rounded-lg shadow-lg max-w-md text-center">
          <h2 class="text-xl font-bold text-yellow-600 mb-4">JavaScript Required</h2>
          <p class="text-gray-600">This game requires JavaScript to function. Please enable JavaScript in your browser and refresh the page.</p>
        </div>
      </div>
    </noscript>

    <!-- Load the JavaScript file -->
    <script>


// tactical-tiles-app.js
// Enhanced JavaScript for Tactical Tiles Game

// Enhanced error handling
window.addEventListener('error', (event) => {
  console.error('Global error:', event.error);
  showErrorBoundary();
});

window.addEventListener('unhandledrejection', (event) => {
  console.error('Unhandled promise rejection:', event.reason);
  showErrorBoundary();
});

function showErrorBoundary() {
  document.getElementById('error-boundary').style.display = 'flex';
  document.getElementById('app').style.display = 'none';
}

// Performance utilities
const debounce = (func, wait) => {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
};

const throttle = (func, limit) => {
  let inThrottle;
  return function() {
    const args = arguments;
    const context = this;
    if (!inThrottle) {
      func.apply(context, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  }
};

// Wait for Vue to load
document.addEventListener('DOMContentLoaded', () => {
  if (typeof Vue === 'undefined') {
    setTimeout(() => {
      if (typeof Vue === 'undefined') {
        showErrorBoundary();
        return;
      }
      initializeApp();
    }, 1000);
  } else {
    initializeApp();
  }
});

function initializeApp() {
  const { createApp } = Vue;

  const app = createApp({
    data() {
      return {
        cells: Array(16).fill(null),
        gridRows: 4,
        isExpanding: false,
        moveHistory: [],
        isShaking: false,
        currentPlayer: "X",
        winner: null,
        isDraw: false,
        winningCombo: [],
        score: { X: 0, O: 0 },
        emojiThemes: [
          { X: "‚ùå", O: "‚≠ï" },
          { X: "üê∂", O: "üê±" },
          { X: "üçï", O: "üçî" },
          { X: "ü¶Ñ", O: "üêâ" },
          { X: "üåü", O: "üåô" },
          { X: "üî•", O: "‚ùÑÔ∏è" },
        ],
        themeIndex: 0,
        peer: null,
        conn: null,
        peerId: "",
        peerIdToConnect: "",
        isHost: false,
        hasUsedUndo: { X: false, O: false },
        hasUsedRemove: { X: false, O: false },
        hasUsedSwap: { X: false, O: false },
        hasUsedExpand: { X: false, O: false },
        swapSelection: [],
        showRemoveMode: false,
        squareEffects: Array(24).fill(false),
        hasUsedSlide: { X: false, O: false },
        hasUsedShield: { X: false, O: false },
        hasUsedTeleport: { X: false, O: false },
        shieldedSquares: Array(24).fill(false),
        slideSelection: [],
        teleportSelection: [],
        slideMode: "select",
        
        // Additional state for improved UX
        isLoading: false,
        gameAnnouncement: "",
        focusedCellIndex: 0,
      };
    },
    
    computed: {
      isMultiplayer() {
        return this.conn !== null;
      },
      emojiSet() {
        return this.emojiThemes[this.themeIndex];
      },
      isMyTurn() {
        if (!this.conn) return true;
        return (
          (this.isHost && this.currentPlayer === "X") ||
          (!this.isHost && this.currentPlayer === "O")
        );
      },
      gameOver() {
        return this.winner || this.isDraw;
      },
      getSlideDestinations() {
        if (this.slideSelection.length !== 1) return [];

        const selectedIndex = this.slideSelection[0];
        if (this.cells[selectedIndex] !== this.currentPlayer) return [];

        const row = Math.floor(selectedIndex / 4);
        const col = selectedIndex % 4;
        const destinations = [];

        const directions = [
          [-1, -1], [-1, 0], [-1, 1],
          [0, -1], [0, 1],
          [1, -1], [1, 0], [1, 1],
        ];

        directions.forEach(([deltaRow, deltaCol]) => {
          const newRow = row + deltaRow;
          const newCol = col + deltaCol;
          const newIndex = newRow * 4 + newCol;

          if (
            newRow >= 0 &&
            newRow < this.gridRows &&
            newCol >= 0 &&
            newCol < 4 &&
            newIndex >= 0 &&
            newIndex < this.cells.length &&
            this.cells[newIndex] === null
          ) {
            destinations.push(newIndex);
          }
        });

        return destinations;
      }
    },
    
    watch: {
      isMyTurn(newVal) {
        if (newVal && !this.winner && !this.isDraw && this.isMultiplayer) {
          this.toaster("üéØ Your turn!", "info", 2000);
        }
      },
      score: {
        handler(val) {
          localStorage.setItem("tictactoe-score", JSON.stringify(val));
        },
        deep: true,
      },
      currentPlayer: {
        handler(newPlayer) {
          if (
            this.cells.every((cell) => cell === null) &&
            this.moveHistory.length === 0
          ) {
            setTimeout(() => {
              if (!this.winner && !this.isDraw) {
                this.toaster(
                  `${this.getEmoji(newPlayer)} goes first!`,
                  "info",
                  2000,
                );
              }
            }, 500);
          }
        },
        immediate: false,
      },
    },
    
    methods: {
      // Enhanced accessibility methods
      getCellAriaLabel(index, cell) {
        const row = Math.floor(index / 4) + 1;
        const col = (index % 4) + 1;
        const position = `Row ${row}, Column ${col}`;
        
        if (cell) {
          const player = cell === 'X' ? 'Player X' : 'Player O';
          const emoji = this.getEmoji(cell);
          return `${position}, occupied by ${player} ${emoji}`;
        } else if (this.isMyTurn && !this.gameOver) {
          return `${position}, empty cell, click to place your piece`;
        } else {
          return `${position}, empty cell`;
        }
      },
      
      getTabIndex(index) {
        if (this.gameOver || !this.isMyTurn) return -1;
        return index === this.focusedCellIndex ? 0 : -1;
      },
      
      announceGameState(message) {
        this.gameAnnouncement = message;
        setTimeout(() => {
          this.gameAnnouncement = "";
        }, 3000);
      },
      
      // Keyboard navigation
      setupKeyboardNavigation() {
        document.addEventListener('keydown', this.handleKeyDown);
      },
      
      handleKeyDown(event) {
        if (!this.isMyTurn || this.gameOver) return;
        
        const currentRow = Math.floor(this.focusedCellIndex / 4);
        const currentCol = this.focusedCellIndex % 4;
        let newIndex = this.focusedCellIndex;
        
        switch(event.key) {
          case 'ArrowRight':
            event.preventDefault();
            if (currentCol < 3) newIndex = this.focusedCellIndex + 1;
            break;
          case 'ArrowLeft':
            event.preventDefault();
            if (currentCol > 0) newIndex = this.focusedCellIndex - 1;
            break;
          case 'ArrowDown':
            event.preventDefault();
            if (currentRow < this.gridRows - 1) newIndex = this.focusedCellIndex + 4;
            break;
          case 'ArrowUp':
            event.preventDefault();
            if (currentRow > 0) newIndex = this.focusedCellIndex - 4;
            break;
          case 'Enter':
          case ' ':
            event.preventDefault();
            if (!this.cells[this.focusedCellIndex]) {
              this.makeMove(this.focusedCellIndex);
            }
            break;
          case 'Home':
            event.preventDefault();
            newIndex = 0;
            break;
          case 'End':
            event.preventDefault();
            newIndex = (this.gridRows * 4) - 1;
            break;
        }
        
        if (newIndex !== this.focusedCellIndex) {
          this.focusedCellIndex = newIndex;
          this.focusCell(newIndex);
        }
      },
      
      focusCell(index) {
        const gameButtons = document.querySelectorAll('[role="gridcell"]');
        if (gameButtons[index]) {
          gameButtons[index].focus();
        }
      },
      
      // Enhanced performance methods
      debouncedFlashSquare: debounce(function(index) {
        this.flashSquare(index);
      }, 100),
      
      throttledToaster: throttle(function(message, type, duration) {
        this.toaster(message, type, duration);
      }, 1000),

      // Game logic methods
      getValidSlideCount(index) {
        if (this.cells[index] !== this.currentPlayer) return 0;

        const row = Math.floor(index / 4);
        const col = index % 4;
        let count = 0;

        const directions = [
          [-1, -1], [-1, 0], [-1, 1],
          [0, -1], [0, 1],
          [1, -1], [1, 0], [1, 1],
        ];

        directions.forEach(([deltaRow, deltaCol]) => {
          const newRow = row + deltaRow;
          const newCol = col + deltaCol;
          const newIndex = newRow * 4 + newCol;

          if (
            newRow >= 0 &&
            newRow < this.gridRows &&
            newCol >= 0 &&
            newCol < 4 &&
            newIndex < this.cells.length &&
            this.cells[newIndex] === null
          ) {
            count++;
          }
        });

        return count;
      },

      hasValidSlideMove() {
        return this.cells.some(
          (cell, index) =>
            cell === this.currentPlayer &&
            this.getValidSlideCount(index) > 0,
        );
      },

      showSlidePowerModal() {
        try {
          this.slideSelection = [];
          this.slideMode = "select";
          document.getElementById("slide-modal").showModal();
        } catch (error) {
          this.handleError("Show slide modal", error);
        }
      },

      performSlide(destinationIndex) {
        try {
          if (this.slideSelection.length !== 1) return;

          const sourceIndex = this.slideSelection[0];
          const validDestinations = this.getSlideDestinations;
          if (!validDestinations.includes(destinationIndex)) {
            this.toaster("Invalid slide destination!", "error");
            return;
          }

          this.flashSquare(sourceIndex);
          this.flashSquare(destinationIndex);

          this.cells[destinationIndex] = this.cells[sourceIndex];
          this.cells[sourceIndex] = null;

          if (this.shieldedSquares[sourceIndex]) {
            this.shieldedSquares[sourceIndex] = false;
            this.shieldedSquares[destinationIndex] = true;
          }

          this.hasUsedSlide[this.currentPlayer] = true;
          document.getElementById("slide-modal").close();
          this.resetSlideSelection();

          this.toaster(
            `${this.getEmoji(this.currentPlayer)} slid a piece!`,
            "info",
          );

          this.checkGameState();

          if (!this.winner && !this.isDraw) {
            this.switchTurn();
          }

          if (this.conn && this.conn.open) {
            this.conn.send({
              type: "slide",
              cells: [...this.cells],
              currentPlayer: this.currentPlayer,
              hasUsedSlide: { ...this.hasUsedSlide },
              shieldedSquares: [...this.shieldedSquares],
              winner: this.winner,
              isDraw: this.isDraw,
              winningCombo: [...this.winningCombo],
            });
          }
        } catch (error) {
          this.handleError("Slide piece", error);
        }
      },

      resetSlideSelection() {
        this.slideSelection = [];
        this.slideMode = "select";
      },

      showShieldPowerModal() {
        try {
          document.getElementById("shield-modal").showModal();
        } catch (error) {
          this.handleError("Show shield modal", error);
        }
      },

      shieldPiece(index) {
        try {
          if (this.hasUsedShield[this.currentPlayer]) return;
          if (this.cells[index] !== this.currentPlayer) return;

          this.flashSquare(index);
          this.shieldedSquares[index] = true;
          this.hasUsedShield[this.currentPlayer] = true;

          document.getElementById("shield-modal").close();

          this.toaster(
            `${this.getEmoji(this.currentPlayer)} shielded a piece!`,
            "success",
          );

          this.switchTurn();

          if (this.conn && this.conn.open) {
            this.conn.send({
              type: "shield",
              currentPlayer: this.currentPlayer,
              hasUsedShield: { ...this.hasUsedShield },
              shieldedSquares: [...this.shieldedSquares],
            });
          }
        } catch (error) {
          this.handleError("Shield piece", error);
        }
      },

      showTeleportPowerModal() {
        try {
          this.teleportSelection = [];
          document.getElementById("teleport-modal").showModal();
        } catch (error) {
          this.handleError("Show teleport modal", error);
        }
      },

      selectTeleportPiece(index) {
        if (this.teleportSelection.length === 0) {
          if (this.cells[index] === this.currentPlayer) {
            this.teleportSelection = [index];
          }
        } else if (this.teleportSelection.length === 1) {
          if (this.cells[index] === null) {
            this.performTeleport(index);
          }
        }
      },

      performTeleport(destinationIndex) {
        try {
          if (this.teleportSelection.length !== 1) return;

          const sourceIndex = this.teleportSelection[0];
          this.flashSquare(sourceIndex);
          this.flashSquare(destinationIndex);

          this.cells[destinationIndex] = this.cells[sourceIndex];
          this.cells[sourceIndex] = null;

          if (this.shieldedSquares[sourceIndex]) {
            this.shieldedSquares[sourceIndex] = false;
            this.shieldedSquares[destinationIndex] = true;
          }

          this.hasUsedTeleport[this.currentPlayer] = true;
          document.getElementById("teleport-modal").close();
          this.resetTeleportSelection();

          this.toaster(
            `${this.getEmoji(this.currentPlayer)} teleported a piece!`,
            "warning",
          );

          this.checkGameState();

          if (!this.winner && !this.isDraw) {
            this.switchTurn();
          }

          if (this.conn && this.conn.open) {
            this.conn.send({
              type: "teleport",
              cells: [...this.cells],
              currentPlayer: this.currentPlayer,
              hasUsedTeleport: { ...this.hasUsedTeleport },
              shieldedSquares: [...this.shieldedSquares],
              winner: this.winner,
              isDraw: this.isDraw,
              winningCombo: [...this.winningCombo],
            });
          }
        } catch (error) {
          this.handleError("Teleport piece", error);
        }
      },

      resetTeleportSelection() {
        this.teleportSelection = [];
      },

      selectSlidePiece(index) {
        if (this.slideMode === "select") {
          if (this.cells[index] === this.currentPlayer) {
            this.slideSelection = [index];
            this.slideMode = "destination";

            const validDestinations = this.getSlideDestinations;
            if (validDestinations.length === 0) {
              this.toaster(
                "This piece cannot slide - no adjacent empty squares!",
                "warning",
                3000,
              );
              this.resetSlideSelection();
              return;
            }
          }
        } else if (this.slideMode === "destination") {
          const validDestinations = this.getSlideDestinations;
          if (validDestinations.includes(index)) {
            this.performSlide(index);
          } else {
            if (this.cells[index] === this.currentPlayer) {
              this.slideSelection = [index];
              const newValidDestinations = this.getSlideDestinations;
              if (newValidDestinations.length === 0) {
                this.toaster(
                  "This piece cannot slide - no adjacent empty squares!",
                  "warning",
                  3000,
                );
                this.resetSlideSelection();
              }
            }
          }
        }
      },

      handleError(operation, error) {
        console.error(`Error in ${operation}:`, error);
        this.toaster(
          `${operation} failed: ${error.message || "Unknown error"}`,
          "error",
          4000,
        );
      },

      cleanUrl() {
        const url = new URL(window.location);
        url.searchParams.delete("gameId");
        window.history.replaceState({}, document.title, url.pathname);
      },

      handleConnectionFailure(message, error = null) {
        if (error) {
          console.error("Connection error:", error);
        }

        this.toaster(message, "error", 4000);

        if (this.peer) {
          try {
            this.peer.destroy();
          } catch (e) {
            console.warn("Error destroying peer:", e);
          }
          this.peer = null;
        }
        this.conn = null;
        this.peerId = "";
        this.peerIdToConnect = "";

        this.cleanUrl();
        const modal = document.getElementById("multiplayer-modal");
        if (modal && modal.open) {
          modal.close();
        }

        this.toaster("Switched to single player mode", "info", 3000);
      },

      switchTurn() {
        if (!this.winner && !this.isDraw) {
          this.currentPlayer = this.currentPlayer === "X" ? "O" : "X";
          if (!this.isMultiplayer || this.isMyTurn) {
            this.toaster(
              `${this.getEmoji(this.currentPlayer)}'s turn`,
              "info",
              1500,
            );
          }
        }
      },

      expandGrid() {
        try {
          if (
            this.hasUsedExpand[this.currentPlayer] ||
            this.gridRows === 6 ||
            this.gameOver
          )
            return;

          this.isExpanding = true;
          this.hasUsedExpand[this.currentPlayer] = true;

          const newRowCount = this.gridRows + 1;
          const currentCellCount = this.gridRows * 4;
          const newCellCount = newRowCount * 4;

          const newCells = Array(newCellCount).fill(null);

          for (let i = 0; i < currentCellCount; i++) {
            newCells[i] = this.cells[i];
          }

          this.cells = newCells;
          this.gridRows = newRowCount;
          this.squareEffects = Array(newCellCount).fill(false);

          setTimeout(() => {
            this.isExpanding = false;
          }, 800);

          this.toaster(
            `${this.getEmoji(this.currentPlayer)} added row ${newRowCount}! Now ${4}√ó${newRowCount}`,
            "warning",
            3000,
          );

          this.switchTurn();

          if (this.conn && this.conn.open) {
            this.conn.send({
              type: "expand",
              cells: [...this.cells],
              gridRows: this.gridRows,
              currentPlayer: this.currentPlayer,
              hasUsedExpand: { ...this.hasUsedExpand },
            });
          }
        } catch (error) {
          this.handleError("Expand grid", error);
        }
      },

      flashSquare(index) {
        this.squareEffects[index] = true;
        setTimeout(() => {
          this.squareEffects[index] = false;
        }, 600);
      },

      shakeScreen() {
        if (this.isShaking) return;
        this.isShaking = true;
        document.body.classList.add("tilt-n-move-shaking");
        setTimeout(() => {
          document.body.classList.remove("tilt-n-move-shaking");
          this.isShaking = false;
        }, 500);
      },

      showMultiplayerModal() {
        document.getElementById("multiplayer-modal").showModal();
      },

      showAboutModal() {
        document.getElementById("about-modal").showModal();
      },

      showSwapPowerModal() {
        try {
          this.swapSelection = [];
          document.getElementById("swap-modal").showModal();
        } catch (error) {
          this.handleError("Show swap modal", error);
        }
      },

      selectSwapPiece(index) {
        if (this.cells[index] === null) return;

        if (this.swapSelection.includes(index)) {
          this.swapSelection = this.swapSelection.filter(
            (i) => i !== index,
          );
        } else if (this.swapSelection.length < 2) {
          this.swapSelection.push(index);

          if (this.swapSelection.length === 2) {
            this.performSwap();
          }
        }
      },

      performSwap() {
        try {
          if (this.swapSelection.length !== 2) return;

          const [index1, index2] = this.swapSelection;
          this.flashSquare(index1);
          this.flashSquare(index2);

          const temp = this.cells[index1];
          this.cells[index1] = this.cells[index2];
          this.cells[index2] = temp;

          const tempShield = this.shieldedSquares[index1];
          this.shieldedSquares[index1] = this.shieldedSquares[index2];
          this.shieldedSquares[index2] = tempShield;

          this.hasUsedSwap[this.currentPlayer] = true;

          document.getElementById("swap-modal").close();
          this.resetSwapSelection();

          this.toaster(
            `${this.getEmoji(this.currentPlayer)} swapped two pieces!`,
            "info",
          );

          this.checkGameState();

          if (!this.winner && !this.isDraw) {
            this.switchTurn();
          }

          if (this.conn && this.conn.open) {
            this.conn.send({
              type: "swap",
              cells: [...this.cells],
              currentPlayer: this.currentPlayer,
              hasUsedSwap: { ...this.hasUsedSwap },
              shieldedSquares: [...this.shieldedSquares],
              winner: this.winner,
              isDraw: this.isDraw,
              winningCombo: [...this.winningCombo],
            });
          }
        } catch (error) {
          this.handleError("Swap pieces", error);
        }
      },

      resetSwapSelection() {
        this.swapSelection = [];
      },

      showRemovePowerModal() {
        try {
          document.getElementById("remove-modal").showModal();
        } catch (error) {
          this.handleError("Show remove modal", error);
        }
      },

      removeOpponentPiece(index) {
        try {
          this.flashSquare(index);
          const opponent = this.currentPlayer === "X" ? "O" : "X";
          if (this.hasUsedRemove[this.currentPlayer]) return;

          if (this.isMultiplayer && this.cells[index] !== opponent) return;
          if (!this.isMultiplayer && this.cells[index] === null) return;

          if (this.shieldedSquares[index]) {
            this.shieldedSquares[index] = false;
            this.toaster("Shield blocked the removal!", "info");
          } else {
            this.cells[index] = null;
          }

          this.hasUsedRemove[this.currentPlayer] = true;
          document.getElementById("remove-modal").close();

          this.toaster(
            `${this.getEmoji(this.currentPlayer)} used remove!`,
            "warning",
          );

          this.switchTurn();

          if (this.conn && this.conn.open) {
            this.conn.send({
              type: "remove",
              cells: [...this.cells],
              currentPlayer: this.currentPlayer,
              hasUsedRemove: { ...this.hasUsedRemove },
              shieldedSquares: [...this.shieldedSquares],
            });
          }
        } catch (error) {
          this.handleError("Remove piece", error);
        }
      },

      undoMove() {
        try {
          const last = this.moveHistory.pop();
          if (!last || this.hasUsedUndo[this.currentPlayer]) return;

          this.flashSquare(last.index);
          this.cells[last.index] = null;
          this.winner = null;
          this.isDraw = false;
          this.winningCombo = [];
          this.hasUsedUndo[this.currentPlayer] = true;

          this.toaster(
            `${this.getEmoji(this.currentPlayer)} undid their last move!`,
            "warning",
          );

          this.switchTurn();

          if (this.conn && this.conn.open) {
            this.conn.send({
              type: "undo",
              cells: [...this.cells],
              currentPlayer: this.currentPlayer,
              winner: this.winner,
              isDraw: this.isDraw,
              winningCombo: [...this.winningCombo],
              moveHistory: [...this.moveHistory],
              hasUsedUndo: { ...this.hasUsedUndo },
            });
          }
        } catch (error) {
          this.handleError("Undo move", error);
        }
      },

      toaster(msg, type = "info", duration = 3000) {
        const colors = {
          info: "#3b82f6",
          success: "#10b981",
          warning: "#f59e0b",
          error: "#ef4444",
        };

        if (window.Toastify) {
          window
            .Toastify({
              text: msg,
              duration: duration,
              gravity: "bottom",
              position: "right",
              backgroundColor: colors[type],
              className: "rounded-xl shadow-lg",
              stopOnFocus: true,
            })
            .showToast();
        } else {
          console.log(`Toast [${type}]: ${msg}`);
        }
      },

      getEmoji(val) {
        return this.emojiSet[val] || " ";
      },

      toggleEmojiTheme() {
        this.themeIndex = (this.themeIndex + 1) % this.emojiThemes.length;
        this.toaster(
          `Theme changed to ${this.emojiSet.X} vs ${this.emojiSet.O}!`,
          "info",
        );
      },

      setupConnection() {
        if (!this.conn) return;

        this.conn.on("open", () => {
          console.log("Connection opened");
          this.toaster("Connection established!", "success");
        });

        this.conn.on("data", (data) => {
          try {
            console.log("Received data:", data);

            if (!data || typeof data !== "object") {
              throw new Error("Invalid data received");
            }

            if (data.type === "move") {
              if (
                !Array.isArray(data.cells) ||
                typeof data.gridRows !== "number"
              ) {
                throw new Error("Invalid move data structure");
              }

              this.cells = [...data.cells];
              this.gridRows = data.gridRows;
              this.currentPlayer = data.currentPlayer;
              this.winner = data.winner;
              this.isDraw = data.isDraw;
              this.winningCombo = [...(data.winningCombo || [])];
              this.score = { ...data.score };
              this.moveHistory = [...(data.moveHistory || [])];
              this.hasUsedUndo = { ...data.hasUsedUndo };
              this.hasUsedRemove = { ...data.hasUsedRemove };
              this.hasUsedSwap = {
                ...(data.hasUsedSwap || { X: false, O: false }),
              };
              this.hasUsedExpand = {
                ...(data.hasUsedExpand || { X: false, O: false }),
              };

              if (this.moveHistory.length > 0) {
                const lastMove =
                  this.moveHistory[this.moveHistory.length - 1];
                this.flashSquare(lastMove.index);
              }
              this.playSound("move");
              this.toaster("Opponent moved!", "info", 1500);
            } else if (data.type === "slide") {
              this.cells = [...data.cells];
              this.currentPlayer = data.currentPlayer;
              this.hasUsedSlide = { ...data.hasUsedSlide };
              this.shieldedSquares = [
                ...(data.shieldedSquares || Array(24).fill(false)),
              ];
              this.winner = data.winner;
              this.isDraw = data.isDraw;
              this.winningCombo = [...(data.winningCombo || [])];

              this.toaster("Opponent used slide!", "info");
              this.playSound("power");
            } else if (data.type === "shield") {
              this.currentPlayer = data.currentPlayer;
              this.hasUsedShield = { ...data.hasUsedShield };
              this.shieldedSquares = [...data.shieldedSquares];
              this.toaster("Opponent used shield!", "success");
              this.playSound("power");
            } else if (data.type === "teleport") {
              this.cells = [...data.cells];
              this.currentPlayer = data.currentPlayer;
              this.hasUsedTeleport = { ...data.hasUsedTeleport };
              this.shieldedSquares = [...data.shieldedSquares];
              this.winner = data.winner;
              this.isDraw = data.isDraw;
              this.winningCombo = [...(data.winningCombo || [])];
              this.toaster("Opponent used teleport!", "warning");
              this.playSound("power");
            } else if (data.type === "reset") {
              this.resetGame(false);
            } else if (data.type === "undo") {
              this.cells = [...data.cells];
              this.currentPlayer = data.currentPlayer;
              this.winner = data.winner;
              this.isDraw = data.isDraw;
              this.winningCombo = [...(data.winningCombo || [])];
              this.moveHistory = [...(data.moveHistory || [])];
              this.hasUsedUndo = { ...data.hasUsedUndo };
              this.toaster("Opponent used undo!", "warning");
              this.playSound("power");
            } else if (data.type === "remove") {
              this.cells = [...data.cells];
              this.currentPlayer = data.currentPlayer;
              this.hasUsedRemove = { ...data.hasUsedRemove };
              this.shieldedSquares = [...(data.shieldedSquares || Array(24).fill(false))];
              this.toaster("Opponent removed a piece!", "warning");
              this.playSound("power");
            } else if (data.type === "swap") {
              this.cells = [...data.cells];
              this.currentPlayer = data.currentPlayer;
              this.hasUsedSwap = { ...data.hasUsedSwap };
              this.shieldedSquares = [...(data.shieldedSquares || Array(24).fill(false))];
              this.winner = data.winner;
              this.isDraw = data.isDraw;
              this.winningCombo = [...(data.winningCombo || [])];
              this.toaster("Opponent used swap!", "info");
              this.playSound("power");
            } else if (data.type === "expand") {
              this.isExpanding = true;
              this.cells = [...data.cells];
              this.gridRows = data.gridRows;
              this.currentPlayer = data.currentPlayer;
              this.hasUsedExpand = { ...data.hasUsedExpand };
              this.squareEffects = Array(this.gridRows * 4).fill(false);
              this.playSound("power");

              setTimeout(() => {
                this.isExpanding = false;
              }, 800);

              this.toaster(
                `Opponent added row ${this.gridRows}! Now 4√ó${this.gridRows}`,
                "warning",
              );
            }
          } catch (error) {
            this.handleError("Processing opponent data", error);
          }
        });

        this.conn.on("close", () => {
          console.log("Connection closed");
          this.toaster("Player disconnected", "error");
          this.conn = null;
        });

        this.conn.on("error", (err) => {
          this.handleError("Connection error", err);
          this.conn = null;
        });
      },

      createGame() {
        try {
          this.isHost = true;
          this.peer = new Peer();

          this.peer.on("open", (id) => {
            this.peerId = id;
            this.toaster("Game created! Share the invite link.", "success");
          });

          this.peer.on("connection", (connection) => {
            this.conn = connection;
            this.setupConnection();
            this.toaster("Player joined the game!", "success");
            document.getElementById("multiplayer-modal").close();
          });

          this.peer.on("error", (err) => {
            this.handleError("Failed to create game", err);
          });
        } catch (error) {
          this.handleError("Create game", error);
        }
      },

      getUrlParameter(name) {
        const params = new URLSearchParams(window.location.search);
        return params.get(name);
      },

      connectToPeer() {
        if (!this.peerIdToConnect.trim()) return;

        this.isHost = false;
        this.peer = new Peer();

        const connectionTimeout = setTimeout(() => {
          this.handleConnectionFailure(
            "Connection timeout - removing invalid game ID from URL",
          );
        }, 10000);

        this.peer.on("open", () => {
          console.log("Peer opened, connecting to:", this.peerIdToConnect);
          this.conn = this.peer.connect(this.peerIdToConnect);

          this.conn.on("open", () => {
            clearTimeout(connectionTimeout);
            console.log("Connected to Game!");
            this.setupConnection();
            this.toaster("Connected to Game!", "success");
            document.getElementById("multiplayer-modal").close();
          });

          this.conn.on("error", (err) => {
            clearTimeout(connectionTimeout);
            this.handleConnectionFailure("Failed to join game", err);
          });
        });

        this.peer.on("error", (err) => {
          clearTimeout(connectionTimeout);
          this.handleConnectionFailure("Failed to join game", err);
        });
      },

      copyPeerIdToClipboard() {
        const link = `${window.location.origin}${window.location.pathname}?gameId=${this.peerId}`;

        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard
            .writeText(link)
            .then(() => {
              this.toaster("Invite link copied to clipboard!", "success");
            })
            .catch((error) => {
              this.handleError("Copy to clipboard", error);
              this.fallbackCopyToClipboard(link);
            });
        } else {
          this.fallbackCopyToClipboard(link);
        }
      },

      fallbackCopyToClipboard(text) {
        try {
          const textArea = document.createElement("textarea");
          textArea.value = text;
          textArea.style.position = "fixed";
          textArea.style.left = "-999999px";
          textArea.style.top = "-999999px";
          document.body.appendChild(textArea);
          textArea.focus();
          textArea.select();
          document.execCommand("copy");
          textArea.remove();
          this.toaster("Invite link copied to clipboard!", "success");
        } catch (error) {
          this.toaster(
            "Please copy this link manually: " + text,
            "info",
            8000,
          );
        }
      },

      makeMove(index) {
        if (
          this.cells[index] ||
          this.winner ||
          this.isDraw ||
          !this.isMyTurn
        )
          return;

        this.playSound("move");
        console.log(
          "Making move at index:",
          index,
          "Current player:",
          this.currentPlayer,
        );

        this.moveHistory.push({ index, player: this.currentPlayer });
        this.cells[index] = this.currentPlayer;
        this.checkGameState();

        this.focusedCellIndex = index;

        if (!this.winner && !this.isDraw) {
          this.switchTurn();
        }

        this.announceGameState(`${this.getEmoji(this.currentPlayer)} placed in ${this.getCellAriaLabel(index, this.currentPlayer)}`);

        if (this.conn) {
          const moveData = {
            type: "move",
            cells: [...this.cells],
            gridRows: this.gridRows,
            currentPlayer: this.currentPlayer,
            winner: this.winner,
            isDraw: this.isDraw,
            winningCombo: [...this.winningCombo],
            score: { ...this.score },
            moveHistory: [...this.moveHistory],
            hasUsedUndo: { ...this.hasUsedUndo },
            hasUsedRemove: { ...this.hasUsedRemove },
            hasUsedSwap: { ...this.hasUsedSwap },
            hasUsedExpand: { ...this.hasUsedExpand },
            hasUsedSlide: { ...this.hasUsedSlide },
            hasUsedShield: { ...this.hasUsedShield },
            hasUsedTeleport: { ...this.hasUsedTeleport },
            shieldedSquares: [...this.shieldedSquares],
          };
          console.log("Sending move data:", moveData);
          this.conn.send(moveData);
        } else {
          console.log("No connection available to send move");
        }
      },

      checkGameState() {
        let wins = [];

        if (this.gridRows === 4) {
          wins = [
            [0, 1, 2], [1, 2, 3], [4, 5, 6], [5, 6, 7],
            [8, 9, 10], [9, 10, 11], [12, 13, 14], [13, 14, 15],
            [0, 4, 8], [4, 8, 12], [1, 5, 9], [5, 9, 13],
            [2, 6, 10], [6, 10, 14], [3, 7, 11], [7, 11, 15],
            [0, 5, 10], [1, 6, 11], [4, 9, 14], [5, 10, 15],
            [2, 5, 8], [3, 6, 9], [6, 9, 12], [7, 10, 13],
          ];
        } else {
          wins = [];

          for (let row = 0; row < this.gridRows; row++) {
            for (let col = 0; col <= 1; col++) {
              const start = row * 4 + col;
              wins.push([start, start + 1, start + 2]);
            }
          }

          for (let col = 0; col < 4; col++) {
            for (let row = 0; row <= this.gridRows - 3; row++) {
              const start = row * 4 + col;
              wins.push([start, start + 4, start + 8]);
            }
          }

          for (let row = 0; row <= this.gridRows - 3; row++) {
            for (let col = 0; col <= 1; col++) {
              const start = row * 4 + col;
              wins.push([start, start + 5, start + 10]);
            }
          }

          for (let row = 0; row <= this.gridRows - 3; row++) {
            for (let col = 2; col <= 3; col++) {
              const start = row * 4 + col;
              wins.push([start, start + 3, start + 6]);
            }
          }
        }

        for (let combo of wins) {
          const [a, b, c] = combo;
          if (
            this.cells[a] &&
            this.cells[a] === this.cells[b] &&
            this.cells[a] === this.cells[c]
          ) {
            this.winner = this.cells[a];
            this.winningCombo = combo;
            this.score[this.winner]++;
            this.toaster(
              `üèÜ ${this.getEmoji(this.winner)} wins!`,
              "success",
              5000,
            );
            this.celebrationFireworks();
            this.playSound("clapping");
            this.announceGameState(`Game over! ${this.getEmoji(this.winner)} wins!`);
            return;
          }
        }

        if (!this.cells.includes(null)) {
          this.isDraw = true;
          this.toaster("ü§ù It's a draw!", "warning", 4000);
          this.announceGameState("Game over! It's a draw!");
        }
      },

      celebrationFireworks() {
        if (typeof confetti === "undefined") return;

        const duration = 3000;
        const animationEnd = Date.now() + duration;
        const defaults = {
          startVelocity: 30,
          spread: 360,
          ticks: 60,
          zIndex: 0,
        };

        function randomInRange(min, max) {
          return Math.random() * (max - min) + min;
        }

        const interval = setInterval(() => {
          const timeLeft = animationEnd - Date.now();

          if (timeLeft <= 0) {
            return clearInterval(interval);
          }

          const particleCount = 50 * (timeLeft / duration);
          confetti({
            ...defaults,
            particleCount,
            origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 },
          });
          confetti({
            ...defaults,
            particleCount,
            origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 },
          });
        }, 250);
      },

      resetGame(sync = true) {
        const gameBoard = document.querySelector(".grid");
        if (gameBoard) gameBoard.classList.add("fade-out");

        setTimeout(() => {
          this.cells = Array(16).fill(null);
          this.gridRows = 4;
          this.isExpanding = false;
          this.moveHistory = [];
          this.currentPlayer = "X";
          this.winner = null;
          this.isDraw = false;
          this.winningCombo = [];
          this.hasUsedUndo = { X: false, O: false };
          this.hasUsedRemove = { X: false, O: false };
          this.hasUsedSwap = { X: false, O: false };
          this.hasUsedExpand = { X: false, O: false };
          this.hasUsedSlide = { X: false, O: false };
          this.hasUsedShield = { X: false, O: false };
          this.hasUsedTeleport = { X: false, O: false };
          this.swapSelection = [];
          this.slideSelection = [];
          this.teleportSelection = [];
          this.slideMode = "select";
          this.shieldedSquares = Array(24).fill(false);
          this.squareEffects = Array(24).fill(false);
          this.focusedCellIndex = 0;
          
          if (gameBoard) gameBoard.classList.remove("fade-out");

          this.toaster("New game started!", "info");
          this.playSound("theme");
          setTimeout(() => {
            this.announceGameState(`${this.getEmoji(this.currentPlayer)} goes first!`);
          }, 500);

          if (sync && this.conn && this.conn.open) {
            this.conn.send({ type: "reset" });
          }
        }, 300);
      },

      playSound(soundName) {
        const audio = new Audio(`/assets/sounds/${soundName}.mp3`);
        audio.volume = 0.3;
        audio.play().catch(e => console.warn('Sound play failed:', e));
      },
    },

    mounted() {
      try {
        document.getElementById('app-loading').style.display = 'none';
        document.getElementById('app').style.display = 'block';
        
        this.setupKeyboardNavigation();
        this.playSound("theme");
        
        try {
          const saved = localStorage.getItem("tictactoe-score");
          if (saved) {
            this.score = JSON.parse(saved);
          }
        } catch (error) {
          console.warn("Failed to load saved score:", error);
          this.score = { X: 0, O: 0 };
        }

        const gameId = this.getUrlParameter("gameId");
        if (gameId) {
          this.peerIdToConnect = gameId;
          this.toaster("Connecting to game...", "info", 3000);
          try {
            this.connectToPeer();
          } catch (error) {
            this.handleConnectionFailure("Failed to connect to game", error);
          }
        }

        setTimeout(() => {
          if (!this.winner && !this.isDraw) {
            this.announceGameState(`${this.getEmoji(this.currentPlayer)} goes first!`);
          }
        }, 1000);
        
      } catch (error) {
        console.error('Error during app initialization:', error);
        showErrorBoundary();
      }
    },
    
    beforeUnmount() {
      document.removeEventListener('keydown', this.handleKeyDown);
      
      if (this.peer) {
        this.peer.destroy();
      }
    }
  });

  app.mount("#app");
}

    </script>
  </body>
</html>

