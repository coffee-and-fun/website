<!DOCTYPE html>
<html class="scroll-smooth antialiased" lang="en" data-theme="retro">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- IMPROVED: Enhanced title with better keywords -->
    <title>
      Tactical Tiles - Free Multiplayer Tic Tac Toe Game Online | Coffee & Fun
      LLC
    </title>

    <!-- IMPROVED: Better meta description with call-to-action -->
    <meta
      name="description"
      content="Play Tactical Tiles - the ultimate multiplayer tic-tac-toe game with power-ups! Challenge friends online, use strategic abilities, and enjoy real-time gameplay. Free, no signup required. Play now!"
    />

    <!-- Additional meta tags -->
    <meta
      name="keywords"
      content="tic tac toe, multiplayer game, online game, power ups, strategy game, free games, browser games, tactical tiles"
    />
    <meta name="language" content="English" />
    <meta name="author" content="Coffee & Fun LLC" />
    <meta
      name="robots"
      content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"
    />
    <meta name="rating" content="safe for kids" />
    <meta name="format-detection" content="telephone=no" />

    <!-- Canonical URL to prevent duplicate content -->
    <link rel="canonical" href="https://www.coffeeandfun.com/tactical-tiles" />

    <!-- Resource hints for better performance -->
    <link rel="dns-prefetch" href="//cdn.jsdelivr.net" />
    <link rel="dns-prefetch" href="//unpkg.com" />
    <link rel="dns-prefetch" href="//cdn.tailwindcss.com" />
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin />

    <!-- Preload critical resources -->
    <link
      rel="preload"
      href="https://cdn.jsdelivr.net/npm/daisyui@4.4.20/dist/full.min.css"
      as="style"
      onload="this.onload=null;this.rel='stylesheet'"
    />
    <noscript
      ><link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/daisyui@4.4.20/dist/full.min.css"
    /></noscript>

    <!-- Load Tailwind with priority -->
    <script src="https://cdn.tailwindcss.com" defer></script>

    <!-- Vue 3 with version pinning for stability -->
    <script
      src="https://unpkg.com/vue@3.4.0/dist/vue.global.prod.js"
      defer
    ></script>

    <!-- Toast notifications -->
    <link
      rel="preload"
      href="https://cdn.jsdelivr.net/npm/toastify-js/src/toastify.min.css"
      as="style"
      onload="this.onload=null;this.rel='stylesheet'"
    />
    <noscript
      ><link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/toastify-js/src/toastify.min.css"
    /></noscript>
    <script src="https://cdn.jsdelivr.net/npm/toastify-js" defer></script>

    <!-- PeerJS for multiplayer -->
    <script
      src="https://unpkg.com/peerjs@1.5.5/dist/peerjs.min.js"
      defer
    ></script>

    <!-- Confetti for celebrations -->
    <script
      src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"
      defer
    ></script>

    <!-- Enhanced structured data -->
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": ["Game", "WebApplication", "SoftwareApplication"],
        "name": "Tactical Tiles",
        "alternateName": "Multiplayer Tic-Tac-Toe with Power Ups",
        "description": "Challenge your friends to a fun, animated Tic-Tac-Toe game with emojis and real-time multiplayer. No account needed. Includes Power Ups!",
        "url": "https://www.coffeeandfun.com/tactical-tiles",
        "applicationCategory": "GameApplication",
        "operatingSystem": "Web Browser",
        "genre": ["Strategy Game", "Puzzle Game", "Board Game"],
        "playMode": ["MultiPlayer", "SinglePlayer"],
        "numberOfPlayers": "1-2",
        "gamePlatform": "Web Browser",
        "contentRating": "Everyone",
        "interactionStatistic": {
          "@type": "InteractionCounter",
          "interactionType": "https://schema.org/PlayAction"
        },
        "offers": {
          "@type": "Offer",
          "price": "0",
          "priceCurrency": "USD",
          "availability": "https://schema.org/InStock"
        },
        "creator": {
          "@type": "Organization",
          "name": "Coffee & Fun LLC",
          "url": "https://www.coffeeandfun.com"
        },
        "datePublished": "2025-01-01",
        "inLanguage": "en",
        "isAccessibleForFree": true,
        "accessibilityFeature": [
          "keyboardNavigation",
          "alternativeText",
          "highContrast",
          "largePrint"
        ],
        "accessibilityControl": [
          "fullKeyboardControl",
          "fullMouseControl",
          "fullTouchControl"
        ]
      }
    </script>

    <!-- Critical CSS inlined for better performance -->
    <style>
      /* Critical styles that must load immediately */
      [v-cloak] {
        display: none;
      }
      /* Ensure grid layout works properly */
      [role="grid"] {
        width: 100%;
        max-width: 400px;
        margin: 0 auto;
      }

      @media (max-width: 640px) {
        [role="grid"] {
          gap: 0.75rem !important;
          max-width: 320px;
        }
      }
      /* Improved loading state */
      .app-loading {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #fef5ec;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 9999;
      }

      /* Performance: Use transform instead of changing layout properties */
      .game-cell {
        aspect-ratio: 1;
        height: 100%;
        width: 100%;
        will-change: transform;
      }

      @media (max-width: 640px) {
        .game-cell {
          min-height: clamp(44px, 15vw, 80px);
          font-size: clamp(1.25rem, 4vw, 1.75rem);
        }

        [role="grid"] {
          gap: 0.75rem !important;
          max-width: 320px;
        }
      }
      .fade-out {
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      .winning-cell {
        animation: pulse 1s infinite;
        background: linear-gradient(45deg, #10b981, #34d399);
      }
      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
      }

      @keyframes flash-effect {
        0% {
          transform: scale(1);
          background-color: transparent;
        }
        50% {
          transform: scale(1.05);
          background-color: rgba(59, 130, 246, 0.3);
        }
        100% {
          transform: scale(1);
          background-color: transparent;
        }
      }

      .flash-effect {
        animation: flash-effect 0.6s ease-in-out;
      }

      @keyframes expand-grid {
        0% {
          transform: scale(0.8);
          opacity: 0.5;
        }
        50% {
          transform: scale(1.1);
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }

      .expand-animation {
        animation: expand-grid 0.8s ease-out;
      }

      .grid-transition {
        transition: all 0.5s ease-in-out;
      }

      @keyframes earthquake {
        0%,
        100% {
          transform: translate(0, 0) rotate(0deg);
        }
        10% {
          transform: translate(-2px, -1px) rotate(-0.5deg);
        }
        20% {
          transform: translate(-3px, 0px) rotate(0.5deg);
        }
        30% {
          transform: translate(3px, 2px) rotate(0deg);
        }
        40% {
          transform: translate(1px, -1px) rotate(0.5deg);
        }
        50% {
          transform: translate(-1px, 2px) rotate(-0.5deg);
        }
        60% {
          transform: translate(-3px, 1px) rotate(0deg);
        }
        70% {
          transform: translate(3px, 1px) rotate(-0.5deg);
        }
        80% {
          transform: translate(-1px, -1px) rotate(0.5deg);
        }
        90% {
          transform: translate(1px, 2px) rotate(0deg);
        }
      }

      .earthquake {
        animation: earthquake 0.8s ease-in-out;
      }

      @keyframes tilt-n-move-shaking {
        0% {
          transform: translate(0, 0) rotate(0deg);
        }
        25% {
          transform: translate(5px, 5px) rotate(5deg);
        }
        50% {
          transform: translate(0, 0) rotate(0deg);
        }
        75% {
          transform: translate(-5px, 5px) rotate(-5deg);
        }
        100% {
          transform: translate(0, 0) rotate(0deg);
        }
      }
      .tilt-n-move-shaking {
        animation: tilt-n-move-shaking 0.5s ease-in-out;
      }

      @keyframes tile-bounce {
        0%,
        100% {
          transform: scale(1) translateY(0);
        }
        25% {
          transform: scale(1.1) translateY(-5px);
        }
        50% {
          transform: scale(1.05) translateY(-2px);
        }
        75% {
          transform: scale(1.02) translateY(-1px);
        }
      }

      .tile-bounce {
        animation: tile-bounce 0.5s ease-out;
      }

      /* Reduced motion support */
      @media (prefers-reduced-motion: reduce) {
        *,
        *::before,
        *::after {
          animation-duration: 0.01ms !important;
          animation-iteration-count: 1 !important;
          transition-duration: 0.01ms !important;
        }
      }

      /* High contrast mode support */
      @media (prefers-contrast: high) {
        .btn {
          border: 2px solid;
        }
      }

      /* Dark mode support */
      @media (prefers-color-scheme: dark) {
        :root {
          color-scheme: dark;
        }
      }
    </style>

    <!-- Better favicon setup -->
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="/assets/images/apps/tic/32.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="/assets/images/apps/tic/16.png"
    />
    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="/assets/images/apps/tic/180.png"
    />
    <link
      rel="mask-icon"
      href="/assets/images/safari-pinned-tab.svg"
      color="#5bbad5"
    />

    <!-- PWA Manifest -->
    <link rel="manifest" href="/assets/images/social/site-tic.webmanifest" />

    <!-- Theme & Mobile Meta -->
    <meta
      name="theme-color"
      content="#fef5ec"
      media="(prefers-color-scheme: light)"
    />
    <meta
      name="theme-color"
      content="#1a1a1a"
      media="(prefers-color-scheme: dark)"
    />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="apple-mobile-web-app-title" content="Tactical Tiles" />
    <meta name="application-name" content="Tactical Tiles" />
    <meta name="msapplication-TileColor" content="#fef5ec" />

    <!-- Enhanced Open Graph Meta Tags -->
    <meta
      property="og:title"
      content="Tactical Tiles - Free Multiplayer Tic Tac Toe Game Online"
    />
    <meta property="og:site_name" content="Coffee & Fun" />
    <meta
      property="og:url"
      content="https://www.coffeeandfun.com/tactical-tiles"
    />
    <meta
      property="og:description"
      content="Play the ultimate multiplayer tic-tac-toe game with power-ups! Challenge friends online, use strategic abilities, and enjoy real-time gameplay. Free, no signup required."
    />
    <meta property="og:type" content="website" />
    <meta
      property="og:image"
      content="https://www.coffeeandfun.com/assets/images/apps/tic/1200.png"
    />
    <meta
      property="og:image:alt"
      content="Tactical Tiles game screenshot showing the game board with power-ups"
    />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:locale" content="en_US" />

    <!-- Twitter Meta Tags -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta
      name="twitter:title"
      content="Tactical Tiles - Free Multiplayer Tic Tac Toe Game Online"
    />
    <meta
      name="twitter:description"
      content="Play the ultimate multiplayer tic-tac-toe game with power-ups! Challenge friends online, use strategic abilities, and enjoy real-time gameplay. Free, no signup required."
    />
    <meta
      name="twitter:image"
      content="https://www.coffeeandfun.com/assets/images/apps/tic/1200.png"
    />
    <meta name="twitter:image:alt" content="Tactical Tiles game screenshot" />
    <meta name="twitter:site" content="@bycoffeeandfun" />
    <meta name="twitter:creator" content="@bycoffeeandfun" />

    <!-- Service Worker registration -->
    <script>
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          navigator.serviceWorker.getRegistrations().then((registrations) => {
            for (const registration of registrations) {
              registration.unregister().then(() => {
                console.log("🧹 Old service worker unregistered");
              });
            }

            navigator.serviceWorker
              .register("/service-worker.js")
              .then((registration) => {
                console.log(
                  "✅ Service Worker registered:",
                  registration.scope,
                );

                registration.addEventListener("updatefound", () => {
                  console.log("🔄 Service Worker update found");
                });
              })
              .catch((error) => {
                console.warn("❌ Service Worker registration failed:", error);
              });
          });
        });
      }

      // Performance monitoring
      window.addEventListener("load", () => {
        if ("performance" in window) {
          const navigation = performance.getEntriesByType("navigation")[0];
          console.log(
            "📊 Page Load Time:",
            navigation.loadEventEnd - navigation.fetchStart,
            "ms",
          );

          if ("web-vital" in window) {
            console.log("📈 Core Web Vitals tracking enabled");
          }
        }
      });
    </script>
  </head>

  <body class="bg-base-100 min-h-screen">
    <!-- Loading screen -->
    <div id="app-loading" class="app-loading">
      <div class="text-center">
        <div class="loading loading-spinner loading-lg text-primary mb-4"></div>
        <p class="text-lg font-semibold">Loading Tactical Tiles...</p>
      </div>
    </div>

    <!-- Skip to main content link for accessibility -->
    <a
      href="#main-content"
      class="sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-4 bg-primary text-primary-content px-4 py-2 rounded-md z-50"
    >
      Skip to main content
    </a>

    <main id="app" style="display: none">
      <!-- Enhanced navbar with better semantics -->
      <nav
        class="navbar border-b-2 border-primary text-primary-content"
        role="navigation"
        aria-label="Main navigation"
      >
        <div class="navbar-start">
          <h1 class="btn btn-soft btn-ghost text-xl" role="banner">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 -960 960 960"
              fill="currentColor"
              class="h-5 w-5"
              role="img"
              aria-label="Game grid icon"
            >
              <title>Tactical Tiles</title>
              <path
                d="M80-80v-240h240v240H80Zm280 0v-240h240v240H360Zm280 0v-240h240v240H640ZM80-360v-240h240v240H80Zm280 0v-240h240v240H360Zm280 0v-240h240v240H640ZM80-640v-240h240v240H80Zm280 0v-240h240v240H360Zm280 0v-240h240v240H640ZM240-240Zm200 0h80-80Zm280 0ZM240-440v-80 80Zm240-40Zm240 40v-80 80ZM440-720h80-80Zm280 0ZM160-160h80v-80h-80v80Zm280 0h80v-80h-80v80Zm280 0h80v-80h-80v80ZM160-440h80v-80h-80v80Zm280 0h80v-80h-80v80Zm280 0h80v-80h-80v80ZM440-720h80v-80h-80v80Zm280 0h80v-80h-80v80Z"
              />
            </svg>
            Tactical Tiles
          </h1>
        </div>

        <div class="navbar-center hidden lg:flex">
          <!-- Better score display with ARIA -->
          <div
            class="badge badge-lg bg-base-100 text-base-content gap-2 px-4"
            role="status"
            aria-label="Game score"
          >
            <span aria-label="Player X score"
              >{{ emojiThemes[themeIndex].X }} {{ score.X }}</span
            >
            <span aria-hidden="true">-</span>
            <span aria-label="Player O score"
              >{{ score.O }} {{ emojiThemes[themeIndex].O }}</span
            >
          </div>
        </div>

        <div class="navbar-end gap-2">
          <button
            @click="showAboutModal"
            class="btn btn-soft btn-primary gap-2 hidden sm:flex"
            aria-label="Open game rules and information"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              class="h-5 w-5"
              viewBox="0 -960 960 960"
              fill="currentColor"
              aria-hidden="true"
            >
              <path
                d="M160-120v-80h480v80H160Zm226-194L160-540l84-86 228 226-86 86Zm254-254L414-796l86-84 226 226-86 86Zm184 408L302-682l56-56 522 522-56 56Z"
              />
            </svg>
            Rules
          </button>

          <div class="dropdown dropdown-end">
            <div
              tabindex="0"
              role="button"
              class="btn btn-soft btn-primary gap-2"
            >
              <template v-if="gameMode === 'offline'">
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  class="h-5 w-5"
                  viewBox="0 -960 960 960"
                  fill="currentColor"
                >
                  <path
                    d="M40-160v-112q0-34 17.5-62.5T104-378q62-31 126-46.5T360-440q66 0 130 15.5T616-378q29 15 46.5 43.5T680-272v112H40Zm720 0v-120q0-44-24.5-84.5T666-434q51 6 96 20.5t84 35.5q36 20 55 44.5t19 53.5v120H760ZM360-480q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47Zm400-160q0 66-47 113t-113 47q-11 0-28-2.5t-28-5.5q27-32 41.5-71t14.5-81q0-42-14.5-81T544-792q14-5 28-6.5t28-1.5q66 0 113 47t47 113ZM120-240h480v-32q0-11-5.5-20T580-306q-54-27-109-40.5T360-360q-56 0-111 13.5T140-306q-9 5-14.5 14t-5.5 20v32Zm240-320q33 0 56.5-23.5T440-640q0-33-23.5-56.5T360-720q-33 0-56.5 23.5T280-640q0 33 23.5 56.5T360-560Zm0 320Zm0-400Z"
                  />
                </svg>
                Local Play</template
              >
              <template v-if="gameMode === 'ai'">
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  class="h-5 w-5"
                  viewBox="0 -960 960 960"
                  fill="currentColor"
                >
                  <path
                    d="M160-360q-50 0-85-35t-35-85q0-50 35-85t85-35v-80q0-33 23.5-56.5T240-760h120q0-50 35-85t85-35q50 0 85 35t35 85h120q33 0 56.5 23.5T800-680v80q50 0 85 35t35 85q0 50-35 85t-85 35v160q0 33-23.5 56.5T720-120H240q-33 0-56.5-23.5T160-200v-160Zm200-80q25 0 42.5-17.5T420-500q0-25-17.5-42.5T360-560q-25 0-42.5 17.5T300-500q0 25 17.5 42.5T360-440Zm240 0q25 0 42.5-17.5T660-500q0-25-17.5-42.5T600-560q-25 0-42.5 17.5T540-500q0 25 17.5 42.5T600-440ZM320-280h320v-80H320v80Zm-80 80h480v-480H240v480Zm240-240Z"
                  />
                </svg>
                AI
              </template>
              <template v-if="gameMode === 'multiplayer'">
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  class="h-5 w-5"
                  viewBox="0 -960 960 960"
                  fill="currentColor"
                >
                  <path
                    d="M480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-7-.5-14.5T799-507q-5 29-27 48t-52 19h-80q-33 0-56.5-23.5T560-520v-40H400v-80q0-33 23.5-56.5T480-720h40q0-23 12.5-40.5T563-789q-20-5-40.5-8t-42.5-3q-134 0-227 93t-93 227h200q66 0 113 47t47 113v40H400v110q20 5 39.5 7.5T480-160Z"
                  />
                </svg>
                Multiplayer</template
              >
              
            </div>
            <ul
              tabindex="0"
              class="dropdown-content z-[1] menu p-2 shadow bg-base-300 rounded-box w-48"
            >
              <li>
                <a
                  @click="setGameMode('offline')"
                  :class="{'active': gameMode === 'offline'}"
                  ><svg
                    xmlns="http://www.w3.org/2000/svg"
                    class="h-5 w-5"
                    viewBox="0 -960 960 960"
                    fill="currentColor"
                  >
                    <path
                      d="M40-160v-112q0-34 17.5-62.5T104-378q62-31 126-46.5T360-440q66 0 130 15.5T616-378q29 15 46.5 43.5T680-272v112H40Zm720 0v-120q0-44-24.5-84.5T666-434q51 6 96 20.5t84 35.5q36 20 55 44.5t19 53.5v120H760ZM360-480q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47Zm400-160q0 66-47 113t-113 47q-11 0-28-2.5t-28-5.5q27-32 41.5-71t14.5-81q0-42-14.5-81T544-792q14-5 28-6.5t28-1.5q66 0 113 47t47 113ZM120-240h480v-32q0-11-5.5-20T580-306q-54-27-109-40.5T360-360q-56 0-111 13.5T140-306q-9 5-14.5 14t-5.5 20v32Zm240-320q33 0 56.5-23.5T440-640q0-33-23.5-56.5T360-720q-33 0-56.5 23.5T280-640q0 33 23.5 56.5T360-560Zm0 320Zm0-400Z"
                    />
                  </svg>
                  Local Play
                </a>
              </li>
              <li>
                <a
                  @click="setGameMode('ai')"
                  :class="{'active': gameMode === 'ai'}"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    class="h-5 w-5"
                    viewBox="0 -960 960 960"
                    fill="currentColor"
                  >
                    <path
                      d="M160-360q-50 0-85-35t-35-85q0-50 35-85t85-35v-80q0-33 23.5-56.5T240-760h120q0-50 35-85t85-35q50 0 85 35t35 85h120q33 0 56.5 23.5T800-680v80q50 0 85 35t35 85q0 50-35 85t-85 35v160q0 33-23.5 56.5T720-120H240q-33 0-56.5-23.5T160-200v-160Zm200-80q25 0 42.5-17.5T420-500q0-25-17.5-42.5T360-560q-25 0-42.5 17.5T300-500q0 25 17.5 42.5T360-440Zm240 0q25 0 42.5-17.5T660-500q0-25-17.5-42.5T600-560q-25 0-42.5 17.5T540-500q0 25 17.5 42.5T600-440ZM320-280h320v-80H320v80Zm-80 80h480v-480H240v480Zm240-240Z"
                    />
                  </svg>
                  AI
                </a>
              </li>
              <li>
                <a
                  @click="setGameMode('multiplayer')"
                  :class="{'active': gameMode === 'multiplayer'}"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    class="h-5 w-5"
                    viewBox="0 -960 960 960"
                    fill="currentColor"
                  >
                    <path
                      d="M480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-7-.5-14.5T799-507q-5 29-27 48t-52 19h-80q-33 0-56.5-23.5T560-520v-40H400v-80q0-33 23.5-56.5T480-720h40q0-23 12.5-40.5T563-789q-20-5-40.5-8t-42.5-3q-134 0-227 93t-93 227h200q66 0 113 47t47 113v40H400v110q20 5 39.5 7.5T480-160Z"
                    />
                  </svg>
                  Multiplayer
                </a>
              </li>
              <div v-if="gameMode === 'ai'" class="divider my-1"></div>
              <li v-if="gameMode === 'ai'">
                <a
                  class="btn btn-ghost btn-sm gap-2"
                  @click="setAIDifficulty('easy')"
                  >🟢 Novice</a
                >
              </li>
              <li v-if="gameMode === 'ai'">
                <a
                  class="btn btn-ghost btn-sm gap-2"
                  @click="setAIDifficulty('medium')"
                  >🟡 Skilled</a
                >
              </li>
              <li v-if="gameMode === 'ai'">
                <a
                  class="btn btn-ghost btn-sm gap-2"
                  @click="setAIDifficulty('hard')"
                  >🔴 Expert</a
                >
              </li>
              <li v-if="gameMode === 'ai'">
                <a
                  class="btn btn-ghost btn-sm gap-2"
                  @click="setAIDifficulty('random')"
                  >🎲 Random</a
                >
              </li>
            </ul>
          </div>
        </div>
      </nav>

      <!-- Game status announcements for screen readers -->
      <div
        class="sr-only"
        aria-live="polite"
        aria-atomic="true"
        id="game-announcements"
      >
        {{ gameAnnouncement }}
      </div>

      <!-- Main content with better landmarks -->
      <section
        id="main-content"
        class="max-w-xl mx-auto space-y-6 px-4 py-8"
        aria-label="Game area"
      >
        <!-- Game Board with enhanced accessibility -->
        <div class="card">
          <div class="card-body">
            <div
              role="grid"
              aria-label="Tic-tac-toe game board"
              aria-describedby="game-instructions"
              :style="{
                display: 'grid',
                gridTemplateColumns: 'repeat(4, 1fr)',
                gridTemplateRows: `repeat(${gridRows}, 1fr)`,
                gap: '1.5rem'
            }"
              :class="[
                'grid-transition',
                isExpanding ? 'expand-animation' : ''
            ]"
            >
              <button
                v-for="(cell, index) in cells"
                :key="index"
                @click="makeMove(index)"
                role="gridcell"
                :aria-label="getCellAriaLabel(index, cell)"
                :aria-pressed="cell !== null"
                :tabindex="getTabIndex(index)"
                :class="[
    'btn mx-auto text-4xl font-bold transition-all duration-200 hover:scale-105 flex items-center justify-center game-cell relative',
    {
      'winning-cell': winner && winningCombo.includes(index),
      'flash-effect': squareEffects[index],
      'ring-2 ring-green-400': shieldedSquares[index],
   'btn-soft btn-disabled': !canMakeMoveAtIndex(index),
'btn-soft btn-primary': !cell && canMakeMoveAtIndex(index),
      'btn-soft btn-ghost': cell
    }
  ]"
                :disabled="!canMakeMoveAtIndex(index)"
              >
                {{ getEmoji(cell) }}
                <span
                  v-if="shieldedSquares[index]"
                  class="absolute top-0 right-0 text-base"
                  aria-label="Shielded"
                  role="img"
                  >🛡️</span
                >
              </button>
            </div>
          </div>
        </div>

        <!-- Hidden instructions for screen readers -->
        <div id="game-instructions" class="sr-only">
          Use arrow keys to navigate the grid and Enter or Space to place your
          piece. Current turn: {{ getEmoji(currentPlayer) }}
        </div>

        <!-- Control Buttons -->
        <div class="flex flex-wrap gap-2 justify-center my-8">
          <button
            v-if="gameOver"
            @click="resetGame"
            class="btn btn-soft btn-success btn-soft btn-wide gap-2"
            aria-label="Start a New Game"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              class="h-5 w-5"
              viewBox="0 -960 960 960"
              fill="currentColor"
            >
              <path
                d="M482-160q-134 0-228-93t-94-227v-7l-64 64-56-56 160-160 160 160-56 56-64-64v7q0 100 70.5 170T482-240q26 0 51-6t49-18l60 60q-38 22-78 33t-82 11Zm278-161L600-481l56-56 64 64v-7q0-100-70.5-170T478-720q-26 0-51 6t-49 18l-60-60q38-22 78-33t82-11q134 0 228 93t94 227v7l64-64 56 56-160 160Z"
              />
            </svg>
            New Game
          </button>
        </div>

        <!-- Power Ups -->
        <h2
          class="text-2xl font-bold text-lect mb-4 text-primary-content mt-12 pt-12"
        >
          ⭐ Power Ups
        </h2>
        <hr class="my-4 border-t-2 border-primary" />
        <div class="grid grid-cols-4 gap-4 mb-6">
          <!-- Undo Power-up -->
          <div class="tooltip" data-tip="Undo Last Move">
            <button
              @click="undoMove"
              class="btn btn-soft btn-secondary btn-soft btn-circle btn-soft btn-lg"
              aria-label="Undo Last Move"
              :class="{ 'btn-soft btn-disabled opacity-50': isPowerUpDisabled('undo') }"
              :disabled="isPowerUpDisabled('undo')"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 -960 960 960"
                class="size-[1.2em]"
                fill="currentColor"
              >
                <path
                  d="M480-80q-75 0-140.5-28.5t-114-77q-48.5-48.5-77-114T120-440h80q0 117 81.5 198.5T480-160q117 0 198.5-81.5T760-440q0-117-81.5-198.5T480-720h-6l62 62-56 58-160-160 160-160 56 58-62 62h6q75 0 140.5 28.5t114 77q48.5 48.5 77 114T840-440q0 75-28.5 140.5t-77 114q-48.5 48.5-114 77T480-80Z"
                />
              </svg>
            </button>
          </div>

          <div class="tooltip" data-tip="Swap Two Pieces">
            <!-- Swap Power-up -->
            <button
              @click="showSwapPowerModal"
              aria-label="Swap Two Pieces"
              class="btn btn-soft btn-info btn-circle btn-lg"
              :class="{ 'btn-soft btn-disabled opacity-50': isPowerUpDisabled('swap') }"
              :disabled="isPowerUpDisabled('swap')"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 -960 960 960"
                class="size-[1.2em]"
                fill="currentColor"
              >
                <path
                  d="m320-160-56-57 103-103H80v-80h287L264-503l56-57 200 200-200 200Zm320-240L440-600l200-200 56 57-103 103h287v80H593l103 103-56 57Z"
                />
              </svg>
            </button>
          </div>

          <div class="tooltip" data-tip="Remove a Piece">
            <!-- Remove Power-up -->
            <button
              @click="showRemovePowerModal"
              aria-label="Remove a Piece"
              class="btn btn-soft btn-neutral btn-soft btn-circle btn-soft btn-lg"
              :class="{ 'btn-soft btn-disabled opacity-50': isPowerUpDisabled('remove') }"
              :disabled="isPowerUpDisabled('remove')"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 -960 960 960"
                class="size-[1.2em]"
                fill="currentColor"
              >
                <path
                  d="M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm400-600H280v520h400v-520ZM360-280h80v-360h-80v360Zm160 0h80v-360h-80v360ZM280-720v520-520Z"
                />
              </svg>
            </button>
          </div>

          <div class="tooltip" data-tip="Add a New Row">
            <!-- Expand Grid Power-up -->
            <button
              @click="expandGrid"
              aria-label="Add a new Row"
              class="btn btn-soft btn-warning btn-soft btn-circle btn-soft btn-lg"
              :class="{ 'btn-soft btn-disabled opacity-50': isPowerUpDisabled('expand') }"
              :disabled="isPowerUpDisabled('expand')"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 -960 960 960"
                class="size-[1.2em]"
                fill="currentColor"
              >
                <path
                  d="M200-200v-160 4-4 160Zm0 80q-33 0-56.5-23.5T120-200v-160q0-33 23.5-56.5T200-440h560q33 0 56.5 23.5T840-360H200v160h400v80H200Zm0-400q-33 0-56.5-23.5T120-600v-160q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v160q0 33-23.5 56.5T760-520H200Zm0-80h560v-160H200v160Zm0 0v-160 160ZM760-40v-80h-80v-80h80v-80h80v80h80v80h-80v80h-80Z"
                />
              </svg>
            </button>
          </div>

          <div class="tooltip" data-tip="Slide a Piece">
            <!-- Slide Power-up -->
            <button
              @click="showSlidePowerModal"
              aria-label="Slide a Piece"
              class="btn btn-soft btn-accent btn-soft btn-circle btn-soft btn-lg"
              :class="{ 'btn-soft btn-disabled opacity-50': isPowerUpDisabled('slide') }"
              :disabled="isPowerUpDisabled('slide')"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 -960 960 960"
                class="size-[1.2em]"
                fill="currentColor"
              >
                <path
                  d="M80-80v-80h160v-80H120v-600h360v180q0 27 16.5 49t42.5 29l105 29q51 14 83.5 56.5T760-400v160H640v80h80q50 0 85-35t35-85h80q0 83-58.5 141.5T720-80H80Zm120-240h480v-80q0-27-16.5-47.5T621-476l-105-30q-36-11-63-35.5T412-600h-72q-8 0-14-6t-6-14q0-8 6-14t14-6h64q-2-12-2.5-20t-1.5-20h-60q-8 0-14-6t-6-14q0-8 6-14t14-6h60v-40H200v440Zm120 160h240v-80H320v80ZM200-320Z"
                />
              </svg>
            </button>
          </div>

          <div class="tooltip" data-tip="Shield a Piece">
            <button
              @click="showShieldPowerModal"
              aria-label="Shield a Piece"
              class="btn btn-soft btn-success btn-soft btn-circle btn-soft btn-lg"
              :class="{ 'btn-soft btn-disabled opacity-50': isPowerUpDisabled('shield') }"
              :disabled="isPowerUpDisabled('shield')"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 -960 960 960"
                class="size-[1.2em]"
                fill="currentColor"
              >
                <path
                  d="M420-360h120l-23-129q20-10 31.5-29t11.5-42q0-33-23.5-56.5T480-640q-33 0-56.5 23.5T400-560q0 23 11.5 42t31.5 29l-23 129Zm60 280q-139-35-229.5-159.5T160-516v-244l320-120 320 120v244q0 152-90.5 276.5T480-80Zm0-84q104-33 172-132t68-220v-189l-240-90-240 90v189q0 121 68 220t172 132Zm0-316Z"
                />
              </svg>
            </button>
          </div>

          <div class="tooltip" data-tip="Teleport a Piece">
            <button
              @click="showTeleportPowerModal"
              aria-label="Teleport a Piece"
              class="btn btn-soft btn-error btn-soft btn-circle btn-soft btn-lg"
              :class="{ 'btn-soft btn-disabled opacity-50': isPowerUpDisabled('teleport') }"
              :disabled="isPowerUpDisabled('teleport')"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 -960 960 960"
                class="size-[1.2em]"
                fill="currentColor"
              >
                <path
                  d="m377-80-57-57 184-183 56 56L377-80Zm199 0-56-57 163-163 57 56L576-80ZM137-520l-57-56 164-164 56 57-163 163Zm0 200-57-57 184-183 56 56-183 184Zm623-21-96-239-78 78 19 94-47 48-71-128-127-70 47-48 94 19 78-78-239-95 60-57 287 45 91-90q9-9 20-13.5t22-4.5q11 0 22 4.5t20 13.5q9 8 13.5 19t4.5 22q0 11-4.5 22.5T862-778l-91 90 45 287-56 60Z"
                />
              </svg>
            </button>
          </div>
        </div>

        <!-- All the modals would continue here exactly as in your original code... -->
        <!-- For brevity, I'm including just the structure. You'd add all your existing modals here -->

        <!-- Shield Power-up Modal -->
        <dialog id="shield-modal" class="modal">
          <div class="modal-box">
            <h3 class="font-bold text-lg mb-4">🛡️ Shield a Piece</h3>
            <p class="text-sm text-base-content/70 mb-4">
              Click on one of your pieces to protect it from removal:
            </p>

            <div class="grid gap-4 mb-4 grid-cols-4">
              <button
                v-for="(cell, index) in cells"
                :key="index"
                aria-label="Shield this Piece"
                @click="shieldPiece(index)"
                :class="[
                  'btn mx-auto text-4xl font-bold transition-all duration-200 hover:scale-105 flex items-center justify-center game-cell relative',
                  {
                    'btn-soft btn-success': cell === currentPlayer && !shieldedSquares[index],
                    'btn-soft btn-ghost': !cell || cell !== currentPlayer,
                    'btn-soft btn-disabled': !cell || cell !== currentPlayer || shieldedSquares[index],
                    'ring-2 ring-green-400': shieldedSquares[index]
                  }
                ]"
                :disabled="!cell || cell !== currentPlayer || shieldedSquares[index]"
              >
                {{ getEmoji(cell) }}
                <span
                  v-if="shieldedSquares[index]"
                  class="absolute top-0 right-0 text-xs"
                  >🛡️</span
                >
              </button>
            </div>

            <div class="modal-action">
              <form method="dialog">
                <button class="btn" aria-label="Close Modal">Cancel</button>
              </form>
            </div>
          </div>
          <form method="dialog" class="modal-backdrop">
            <button aria-label="Close Modal">close</button>
          </form>
        </dialog>

        <!-- Teleport Piece Modal -->
        <dialog id="teleport-modal" class="modal">
          <div class="modal-box">
            <h3 class="font-bold text-lg mb-4">🚀 Teleport a Piece</h3>
            <p class="text-sm text-base-content/70 mb-4">
              <span v-if="teleportSelection.length === 0"
                ><strong>Step 1:</strong>Click on one of your pieces to
                teleport:</span
              >
              <span v-else
                ><strong>Step 2:</strong>Click on any empty square to teleport
                to:</span
              >
            </p>
            <p
              class="text-xs text-error mb-4"
              v-if="teleportSelection.length === 1"
            >
              Selected: {{ getEmoji(cells[teleportSelection[0]]) }} - Now pick any empty space
            </p>

            <div class="grid gap-4 mb-4 grid-cols-4">
              <button
                v-for="(cell, index) in cells"
                :key="index"
                aria-label="Select for Teleport"
                @click="selectTeleportPiece(index)"
                :class="[
                  'btn mx-auto text-4xl font-bold transition-all duration-200 hover:scale-105 flex items-center justify-center game-cell relative',
                  {
                    'btn-soft btn-error': teleportSelection.includes(index),
                    'btn-soft btn-primary': teleportSelection.length === 1 && cell === null,
                    'btn-soft btn-secondary': cell === currentPlayer && !teleportSelection.includes(index),
                    'btn-soft btn-ghost': !cell && teleportSelection.length === 0,
                    'btn-soft btn-disabled': (teleportSelection.length === 0 && cell !== currentPlayer) || 
                                  (teleportSelection.length === 1 && cell !== null)
                  }
                ]"
                :disabled="(teleportSelection.length === 0 && cell !== currentPlayer) || 
                          (teleportSelection.length === 1 && cell !== null)"
              >
                {{ getEmoji(cell) }}
                <span
                  v-if="shieldedSquares[index]"
                  class="absolute top-0 right-0 text-xs"
                  >🛡️</span
                >
              </button>
            </div>

            <div class="modal-action">
              <form method="dialog">
                <button
                  class="btn"
                  aria-label="Close Modal"
                  @click="resetTeleportSelection"
                >
                  Cancel
                </button>
              </form>
            </div>
          </div>
          <form method="dialog" class="modal-backdrop">
            <button aria-label="Close Modal" @click="resetTeleportSelection">
              close
            </button>
          </form>
        </dialog>

        <!-- Slide Piece Modal -->
        <dialog id="slide-modal" class="modal">
          <div class="modal-box">
            <h3 class="font-bold text-lg mb-4">🔀 Slide a Piece</h3>

            <p class="text-sm text-base-content/70 mb-4">
              <span v-if="slideMode === 'select'"
                ><strong>Step 1:</strong> Click on one of your pieces to
                slide</span
              >
              <span v-else>Click on any empty square to teleport to:</span>
            </p>

            <p
              class="text-xs text-accent mb-4"
              v-if="slideSelection.length === 1"
            >
              Selected piece: {{ getEmoji(cells[slideSelection[0]])
              }}
              <span
                v-if="getSlideDestinations.length === 0"
                class="text-warning"
              >
                - No valid moves available!</span
              >
              <span v-else class="text-success">
                - {{ getSlideDestinations.length }}
                possible moves</span
              >
            </p>

            <div class="grid gap-4 mb-4 grid-cols-4">
              <button
                v-for="(cell, index) in cells"
                :key="index"
                aria-label="Select this Tile for Sliding"
                @click="selectSlidePiece(index)"
                :class="[
                  'btn mx-auto text-4xl font-bold transition-all duration-200 hover:scale-105 flex items-center justify-center game-cell relative',
                  {
                    'btn-soft btn-accent border-4 border-accent': slideSelection.includes(index),
                    'btn-soft btn-primary ring-2 ring-primary animate-pulse': slideMode === 'destination' && getSlideDestinations.includes(index),
                    'btn-soft btn-secondary hover:btn-soft btn-accent': cell === currentPlayer && slideMode === 'select' && !slideSelection.includes(index),
                    'btn-soft btn-ghost': !cell && (slideMode === 'select' || !getSlideDestinations.includes(index)),
                    'btn-soft btn-disabled opacity-30': (slideMode === 'select' && cell !== currentPlayer && cell !== null) || 
                                             (slideMode === 'destination' && !getSlideDestinations.includes(index) && cell !== currentPlayer),
                    'ring-2 ring-green-400': shieldedSquares[index]
                  }
                ]"
                :disabled="(slideMode === 'select' && cell !== currentPlayer && cell !== null) || 
                          (slideMode === 'destination' && !getSlideDestinations.includes(index) && cell !== currentPlayer)"
              >
                {{ getEmoji(cell) }}
                <span
                  v-if="shieldedSquares[index]"
                  class="absolute top-0 right-0 text-xs"
                  >🛡️</span
                >

                <span
                  v-if="slideMode === 'destination' && getSlideDestinations.includes(index)"
                  class="absolute inset-0 flex items-center justify-center text-2xl"
                >
                  ✨
                </span>
              </button>
            </div>

            <div class="text-xs text-base-content/70 mb-4">
              <p v-if="slideMode === 'select'">
                💡 <strong>Tip:</strong> Pieces can slide to any adjacent empty
                square, including diagonally
              </p>
              <p v-else>
                💡 <strong>Tip:</strong> Click on your selected piece again to
                choose a different piece to slide
              </p>
            </div>

            <div class="modal-action">
              <form method="dialog">
                <button
                  class="btn"
                  aria-label="Close Modal"
                  @click="resetSlideSelection"
                >
                  Cancel
                </button>
              </form>
            </div>
          </div>
          <form method="dialog" class="modal-backdrop">
            <button aria-label="Close Modal" @click="resetSlideSelection">
              close
            </button>
          </form>
        </dialog>

        <!-- Swap Piece Modal -->
        <dialog id="swap-modal" class="modal">
          <div class="modal-box">
            <h3 class="font-bold text-lg mb-4">🔄 Swap Two Pieces</h3>
            <p class="text-sm text-base-content/70 mb-4">
              Click on two pieces to swap their positions:
            </p>
            <p class="text-xs text-info mb-4" v-if="swapSelection.length === 1">
              Selected: {{ getEmoji(cells[swapSelection[0]]) }} - Now pick a second piece to swap with
            </p>

            <div class="grid gap-4 mb-4 grid-cols-4">
              <button
                v-for="(cell, index) in cells"
                :key="index"
                aria-label="Select this Tile to Swap"
                @click="selectSwapPiece(index)"
                :class="[
                  'btn mx-auto text-4xl font-bold transition-all duration-200 hover:scale-105 flex items-center justify-center game-cell relative',
                  {
                    'btn-soft btn-info': swapSelection.includes(index),
                    'btn-soft btn-secondary': cell !== null && !swapSelection.includes(index),
                    'btn-soft btn-ghost': !cell,
                    'btn-soft btn-disabled': !cell
                  }
                ]"
                :disabled="!cell"
              >
                {{ getEmoji(cell) }}
                <span
                  v-if="shieldedSquares[index]"
                  class="absolute top-0 right-0 text-xs"
                  >🛡️</span
                >
              </button>
            </div>

            <div class="modal-action">
              <form method="dialog">
                <button
                  class="btn"
                  aria-label="Close Modal"
                  @click="resetSwapSelection"
                >
                  Cancel
                </button>
              </form>
            </div>
          </div>
          <form method="dialog" class="modal-backdrop">
            <button aria-label="Close Modal" @click="resetSwapSelection">
              close
            </button>
          </form>
        </dialog>

        <!-- About Modal -->
        <dialog id="about-modal" class="modal">
          <div class="modal-box max-w-2xl">
            <h3 class="font-bold text-2xl mb-6 text-center">
              🎮 About Tactical Tiles
            </h3>

            <div class="space-y-6">
              <div>
                <h4 class="font-bold text-lg mb-3 text-primary">
                  🚀 What Makes This Different?
                </h4>
                <div class="space-y-2 text-base-content/80">
                  <p>
                    • <strong>Real-time multiplayer</strong> - Play instantly
                    with friends anywhere in the world
                  </p>
                  <p>
                    • <strong>Power Ups</strong> - Strategic abilities to turn
                    the tide of battle
                  </p>
                  <p>
                    • <strong>Dynamic grid expansion</strong> - Expand from 4×4
                    to 5×5 mid-game!
                  </p>
                  <p>
                    • <strong>Customizable themes</strong> - Choose from fun
                    emoji pairs like 🐶 vs 🐱
                  </p>
                  <p>
                    • <strong>No registration required</strong> - Just share a
                    link and start playing
                  </p>
                  <p>
                    • <strong>Cross-platform</strong> - Works on phones,
                    tablets, and computers
                  </p>
                </div>
              </div>

              <div>
                <h4 class="font-bold text-lg mb-3 text-secondary">
                  📋 How to Play
                </h4>
                <div class="space-y-3">
                  <div>
                    <h5 class="font-semibold text-base mb-1">Basic Rules:</h5>
                    <div class="text-base-content/80 space-y-1">
                      <p>• Take turns placing your emoji on the grid</p>
                      <p>
                        • Get three in a row (horizontal, vertical, or diagonal)
                        to win
                      </p>
                      <p>
                        • The grid starts as 4×4 but can be expanded to 4×6 with
                        Power Ups (each player can add one row)
                      </p>
                      <p>
                        • If all spaces are filled without a winner, it's a draw
                      </p>
                    </div>
                  </div>

                  <div>
                    <h5 class="font-semibold text-base mb-1">Single Player:</h5>
                    <p class="text-base-content/80">
                      • Play against yourself or use it to practice strategies
                    </p>
                  </div>

                  <div>
                    <h5 class="font-semibold text-base mb-1">Multiplayer:</h5>
                    <div class="text-base-content/80 space-y-1">
                      <p>• Click "Multiplayer" to create a game or join one</p>
                      <p>• Share the invite link with your friend</p>
                      <p>
                        • Host plays as ❌ (or first emoji), guest plays as ⭕
                        (or second emoji)
                      </p>
                    </div>
                  </div>
                </div>
              </div>

              <div>
                <h4 class="font-bold text-lg mb-3 text-warning">
                  ⚡ Power Ups
                </h4>
                <div class="space-y-2">
                  <div class="flex items-start gap-3">
                    <div class="badge badge-warning badge-sm mt-1">UNDO</div>
                    <div class="text-base-content/80">
                      <strong>Undo Move:</strong> Take back your last move. Each
                      player gets one undo per game.
                    </div>
                  </div>
                  <div class="flex items-start gap-3">
                    <div class="badge badge-info badge-sm mt-1">SWAP</div>
                    <div class="text-base-content/80">
                      <strong>Swap Piece:</strong> Swap two pieces on the board.
                      Each player gets one swap per game.
                    </div>
                  </div>
                  <div class="flex items-start gap-3">
                    <div class="badge badge-accent badge-sm mt-1">SLIDE</div>
                    <div class="text-base-content/80">
                      <strong>Slide Piece:</strong> Move one of your pieces to
                      an adjacent empty square (including diagonally). Great for
                      positioning and last-minute saves.
                    </div>
                  </div>
                  <div class="flex items-start gap-3">
                    <div class="badge badge-success badge-sm mt-1">SHIELD</div>
                    <div class="text-base-content/80">
                      <strong>Shield Piece:</strong> Protect one of your pieces
                      from the next removal attempt. Shielded pieces show a 🛡️
                      icon and will block ONE removal - the shield disappears
                      after blocking.
                    </div>
                  </div>
                  <div class="flex items-start gap-3">
                    <div class="badge badge-error badge-sm mt-1">TELEPORT</div>
                    <div class="text-base-content/80">
                      <strong>Teleport:</strong> Move any of your pieces to any
                      empty square on the board. The ultimate positioning
                      power-up!
                    </div>
                  </div>
                  <div class="flex items-start gap-3">
                    <div class="badge badge-error badge-sm mt-1">REMOVE</div>
                    <div class="text-base-content/80">
                      <strong>Remove Piece:</strong> Eliminate a piece from the
                      board. Each player gets one removal per game.
                    </div>
                  </div>
                  <div class="flex items-start gap-3">
                    <div class="badge badge-accent badge-sm mt-1">EXPAND</div>
                    <div class="text-base-content/80">
                      <strong>Add Row:</strong> Add an extra row to the grid.
                      The grid can expand from 4×4 to 4×5 to 4×6 as each player
                      uses their expansion. Each player gets one row expansion
                      per game.
                    </div>
                  </div>
                  <div class="alert alert-info mt-3">
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      class="stroke-current shrink-0 h-5 w-5"
                      fill="none"
                      viewBox="0 0 24 24"
                    >
                      <path
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        stroke-width="2"
                        d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
                      />
                    </svg>
                    <span class="text-sm"
                      >Each player gets ONE of each power-up per game. Use them
                      strategically - timing is everything!</span
                    >
                  </div>
                </div>
              </div>

              <div>
                <h4 class="font-bold text-lg mb-3 text-accent">💡 Pro Tips</h4>
                <div class="space-y-2 text-base-content/80">
                  <p>
                    • <strong>Control the center:</strong> The middle squares
                    give you the most winning opportunities
                  </p>
                  <p>
                    • <strong>Block and build:</strong> Always block your
                    opponent's winning moves
                  </p>
                  <p>
                    • <strong>Think ahead:</strong> Look for moves that create
                    multiple winning threats
                  </p>
                  <p>
                    • <strong>Save Power Ups:</strong> Don't use them too early
                    - wait for the perfect moment
                  </p>
                  <p>
                    • <strong>Shield strategically:</strong> Protect key pieces
                    that are part of potential winning combinations
                  </p>
                  <p>
                    • <strong>Slide for setup:</strong> Use slide to create
                    unexpected winning patterns or escape threats
                  </p>
                  <p>
                    • <strong>Teleport timing:</strong> Best used for surprise
                    attacks or defensive repositioning
                  </p>
                  <p>
                    • <strong>Grid expansion strategy:</strong> Adding rows can
                    break deadlocks and create new winning paths
                  </p>
                  <p>
                    • <strong>Power-up combos:</strong> Think about how
                    different Power Ups work together (shield then expand, slide
                    then teleport)
                  </p>
                </div>
              </div>

              <div class="bg-base-200 p-4 rounded-lg">
                <h4 class="font-bold text-lg mb-2">🎯 Fun Facts</h4>
                <div class="text-sm text-base-content/70 space-y-1">
                  <p>• Tic-tac-toe has been played for over 2,000 years</p>
                  <p>• A perfect 3×3 game always ends in a draw</p>
                  <p>
                    • This version's Power Ups break the "always draw" rule!
                  </p>
                  <p>
                    • Grid expansion creates 255,168 new possible game states
                  </p>
                </div>
              </div>
            </div>

            <div class="modal-action">
              <form method="dialog">
                <button class="btn btn-soft btn-primary">
                  Got it, let's play! 🎮
                </button>
              </form>
            </div>
          </div>
          <form method="dialog" class="modal-backdrop">
            <button>close</button>
          </form>
        </dialog>

        <!-- Multiplayer Modal -->
        <dialog id="multiplayer-modal" class="modal">
          <div class="modal-box">
            <h3 class="font-bold text-lg mb-4">🌐 Multiplayer Game</h3>

            <div class="space-y-4">
              <button
                @click="createGame"
                class="btn btn-soft btn-primary btn-soft btn-block gap-2"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  class="h-5 w-5"
                  fill="none"
                  viewBox="0 0 24 24"
                  stroke="currentColor"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M12 6v6m0 0v6m0-6h6m-6 0H6"
                  />
                </svg>
                Create New Game
              </button>

              <div v-if="peerId" class="space-y-2">
                <p class="text-sm text-base-content/70">
                  Game created! Share this link:
                </p>
                <button
                  @click="copyPeerIdToClipboard"
                  class="btn btn-soft btn-outline btn-soft btn-block gap-2"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    class="h-4 w-4"
                    viewBox="0 -960 960 960"
                    fill="currentColor"
                  >
                    <path
                      d="M360-240q-33 0-56.5-23.5T280-320v-480q0-33 23.5-56.5T360-880h360q33 0 56.5 23.5T800-800v480q0 33-23.5 56.5T720-240H360Zm0-80h360v-480H360v480ZM200-80q-33 0-56.5-23.5T120-160v-560h80v560h440v80H200Zm160-240v-480 480Z"
                    />
                  </svg>
                  Copy Invite Link
                </button>
              </div>

              <div class="divider">OR</div>

              <div class="space-y-2">
                <label class="label">
                  <span class="label-text">Join existing game:</span>
                </label>
                <div class="join w-full">
                  <input
                    v-model="peerIdToConnect"
                    placeholder="Enter game ID"
                    class="input input-bordered join-item flex-1"
                  />
                  <button
                    @click="connectToPeer"
                    class="btn btn-soft btn-primary join-item"
                    :disabled="!peerIdToConnect.trim()"
                  >
                    Join
                  </button>
                </div>
              </div>
            </div>

            <div class="modal-action">
              <form method="dialog">
                <button aria-label="Close Modal" class="btn">Close</button>
              </form>
            </div>
          </div>
          <form method="dialog" class="modal-backdrop">
            <button aria-label="Close Modal">close</button>
          </form>
        </dialog>

        <!-- Remove Piece Modal -->
        <dialog id="remove-modal" class="modal">
          <div class="modal-box">
            <h3 class="font-bold text-lg mb-4">🗑️ Remove a Piece</h3>
            <p class="text-sm text-base-content/70 mb-4">
              <span v-if="isMultiplayer"
                >Click on an opponent's piece to remove it:</span
              >
              <span v-else>Click on any piece to remove it:</span>
            </p>

            <div class="grid gap-4 mb-4 grid-cols-4">
              <button
                v-for="(cell, index) in cells"
                :key="index"
                aria-label="Remove this Tile"
                @click="removeOpponentPiece(index)"
                :class="[
                  'btn mx-auto text-4xl font-bold transition-all duration-200 hover:scale-105 flex items-center justify-center game-cell relative',
                  {
                    'btn-soft btn-error': isMultiplayer ? cell === (currentPlayer === 'X' ? 'O' : 'X') : cell !== null,
                    'btn-soft btn-ghost': !cell,
                    'btn-soft btn-disabled': !cell || (isMultiplayer && cell === currentPlayer),
                    'ring-2 ring-green-400': shieldedSquares[index]
                  }
                ]"
                :disabled="!cell || (isMultiplayer && cell === currentPlayer)"
              >
                {{ getEmoji(cell) }}
                <span
                  v-if="shieldedSquares[index]"
                  class="absolute top-0 right-0 text-xs"
                  >🛡️</span
                >
              </button>
            </div>

            <div class="modal-action">
              <form method="dialog">
                <button aria-label="Close Modal" class="btn">Cancel</button>
              </form>
            </div>
          </div>
          <form method="dialog" class="modal-backdrop">
            <button aria-label="Close Modal">close</button>
          </form>
        </dialog>
      </section>
    </main>

    <!-- Enhanced error boundary -->
    <div
      id="error-boundary"
      style="display: none"
      class="fixed inset-0 bg-red-50 flex items-center justify-center z-50"
    >
      <div class="bg-white p-8 rounded-lg shadow-lg max-w-md text-center">
        <h2 class="text-xl font-bold text-red-600 mb-4">
          Oops! Something went wrong
        </h2>
        <p class="text-gray-600 mb-4">
          The game encountered an error. Please refresh the page to try again.
        </p>
        <button
          onclick="window.location.reload()"
          class="btn btn-soft btn-primary"
        >
          Refresh Page
        </button>
      </div>
    </div>

    <!-- Non-JS fallback -->
    <noscript>
      <div class="fixed inset-0 bg-yellow-50 flex items-center justify-center">
        <div class="bg-white p-8 rounded-lg shadow-lg max-w-md text-center">
          <h2 class="text-xl font-bold text-yellow-600 mb-4">
            JavaScript Required
          </h2>
          <p class="text-gray-600">
            This game requires JavaScript to function. Please enable JavaScript
            in your browser and refresh the page.
          </p>
        </div>
      </div>
    </noscript>

    <!-- Load the JavaScript file -->
    <script>
      // tactical-tiles-app.js
      // Enhanced JavaScript for Tactical Tiles Game

      // Enhanced error handling
      window.addEventListener("error", (event) => {
        console.error("Global error:", event.error);
        showErrorBoundary();
      });

      window.addEventListener("unhandledrejection", (event) => {
        console.error("Unhandled promise rejection:", event.reason);
        showErrorBoundary();
      });

      function showErrorBoundary() {
        document.getElementById("error-boundary").style.display = "flex";
        document.getElementById("app").style.display = "none";
      }

      // Performance utilities
      const debounce = (func, wait) => {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      };

      const throttle = (func, limit) => {
        let inThrottle;
        return function () {
          const args = arguments;
          const context = this;
          if (!inThrottle) {
            func.apply(context, args);
            inThrottle = true;
            setTimeout(() => (inThrottle = false), limit);
          }
        };
      };

      // Wait for Vue to load
      document.addEventListener("DOMContentLoaded", () => {
        if (typeof Vue === "undefined") {
          setTimeout(() => {
            if (typeof Vue === "undefined") {
              showErrorBoundary();
              return;
            }
            initializeApp();
          }, 1000);
        } else {
          initializeApp();
        }
      });

      function initializeApp() {
        const { createApp } = Vue;

        const app = createApp({
          data() {
            return {
              // Game Mode Management
              gameMode: "offline", // 'offline', 'ai', 'multiplayer'
              isAIMode: false,
              aiDifficulty: "random",
              aiPlayer: "O",
              aiThinking: false,
              aiPersonality: null,

              // AI skill parameters (randomized each game)
              aiSkills: {
                strategicThinking: 0.5,
                powerUpTiming: 0.5,
                defensivePlay: 0.5,
                riskTaking: 0.5,
                adaptability: 0.5,
              },

              // AI thinking delay ranges
              aiDelayRanges: {
                easy: [800, 1500],
                medium: [1200, 2500],
                hard: [1500, 3000],
                random: [800, 3000],
              },
              cells: Array(16).fill(null),
              gridRows: 4,
              isExpanding: false,
              moveHistory: [],
              isShaking: false,
              currentPlayer: "X",
              winner: null,
              isDraw: false,
              winningCombo: [],
              score: { X: 0, O: 0 },
              emojiThemes: [
                { X: "❌", O: "⭕" },
                { X: "🐶", O: "🐱" },
                { X: "🍕", O: "🍔" },
                { X: "🦄", O: "🐉" },
                { X: "🌟", O: "🌙" },
                { X: "🔥", O: "❄️" },
              ],
              themeIndex: 0,
              peer: null,
              conn: null,
              peerId: "",
              peerIdToConnect: "",
              isHost: false,
              hasUsedUndo: { X: false, O: false },
              hasUsedRemove: { X: false, O: false },
              hasUsedSwap: { X: false, O: false },
              hasUsedExpand: { X: false, O: false },
              swapSelection: [],
              showRemoveMode: false,
              squareEffects: Array(24).fill(false),
              hasUsedSlide: { X: false, O: false },
              hasUsedShield: { X: false, O: false },
              hasUsedTeleport: { X: false, O: false },
              shieldedSquares: Array(24).fill(false),
              slideSelection: [],
              teleportSelection: [],
              slideMode: "select",

              // Additional state for improved UX
              isLoading: false,
              gameAnnouncement: "",
              focusedCellIndex: 0,
            };
          },

          computed: {
            aiShouldMove() {
              return (
                this.gameMode === "ai" &&
                this.currentPlayer === this.aiPlayer &&
                !this.gameOver
              );
            },

            isPlayerTurn() {
              return (
                this.gameMode !== "ai" || this.currentPlayer !== this.aiPlayer
              );
            },

            isMultiplayer() {
              return this.gameMode === "multiplayer" && this.conn !== null;
            },

            gameStatusText() {
              switch (this.gameMode) {
                case "offline":
                  return "Local Play";
                case "ai":
                  return `vs AI (${this.getAIDifficultyName()})`;
                case "multiplayer":
                  return this.conn ? "Online Multiplayer" : "Connecting...";
                default:
                  return "Game";
              }
            },
            emojiSet() {
              return this.emojiThemes[this.themeIndex];
            },
            isMyTurn() {
              if (this.gameMode === "ai") {
                return this.currentPlayer === "X" || this.gameOver;
              }

              // In multiplayer mode, check connection and player role
              if (!this.conn) return true;
              return (
                (this.isHost && this.currentPlayer === "X") ||
                (!this.isHost && this.currentPlayer === "O")
              );
            },

            gameOver() {
              return this.winner || this.isDraw;
            },
            getSlideDestinations() {
              if (this.slideSelection.length !== 1) return [];

              const selectedIndex = this.slideSelection[0];
              if (this.cells[selectedIndex] !== this.currentPlayer) return [];

              const row = Math.floor(selectedIndex / 4);
              const col = selectedIndex % 4;
              const destinations = [];

              const directions = [
                [-1, -1],
                [-1, 0],
                [-1, 1],
                [0, -1],
                [0, 1],
                [1, -1],
                [1, 0],
                [1, 1],
              ];

              directions.forEach(([deltaRow, deltaCol]) => {
                const newRow = row + deltaRow;
                const newCol = col + deltaCol;
                const newIndex = newRow * 4 + newCol;

                if (
                  newRow >= 0 &&
                  newRow < this.gridRows &&
                  newCol >= 0 &&
                  newCol < 4 &&
                  newIndex >= 0 &&
                  newIndex < this.cells.length &&
                  this.cells[newIndex] === null
                ) {
                  destinations.push(newIndex);
                }
              });

              return destinations;
            },
          },

          watch: {
            currentPlayer: {
    handler(newPlayer, oldPlayer) {
      // Prevent infinite loops and duplicate calls
      if (newPlayer === oldPlayer || this.gameOver) return;
      
      console.log(`Player changed from ${oldPlayer} to ${newPlayer}`);
      
      // Only trigger AI if it's actually AI's turn and game is active
      if (this.gameMode === 'ai' && 
          newPlayer === this.aiPlayer && 
          !this.gameOver && 
          !this.aiThinking) {
        
        console.log("Triggering AI move");
        // Use nextTick to ensure all reactive updates are complete
        this.$nextTick(() => {
          if (this.currentPlayer === this.aiPlayer && 
              !this.gameOver && 
              !this.aiThinking) {
            this.makeAIMove();
          }
        });
      }
    },
    immediate: false,
  },


            isMyTurn(newVal) {
              if (
                newVal &&
                !this.winner &&
                !this.isDraw &&
                this.isMultiplayer
              ) {
                this.toaster("🎯 Your turn!", "info", 2000);
              }
            },
            score: {
              handler(val) {
                localStorage.setItem("tictactoe-score", JSON.stringify(val));
              },
              deep: true,
            },
          },

          methods: {
            // Complete createGame method - add this to your methods section




createGame() {
  console.log("Creating new multiplayer game...");
  
  // Clean up any existing peer connection
  if (this.peer) {
    try {
      this.peer.destroy();
    } catch (error) {
      console.warn("Error destroying existing peer:", error);
    }
    this.peer = null;
  }

  // Reset connection state
  this.isHost = true;
  this.conn = null;
  this.peerId = "";
  
  // Create new peer with enhanced configuration
  this.peer = new Peer({
    debug: 1, // Reduced debug level
    config: {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:global.stun.twilio.com:3478' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ]
    }
  });

  // Set up peer event handlers
  this.peer.on("open", (id) => {
    this.peerId = id;
    console.log("Game created with ID:", id);
    
    // Update URL with game ID
    try {
      const url = new URL(window.location);
      url.searchParams.set('gameId', id);
      window.history.pushState({}, document.title, url.toString());
    } catch (error) {
      console.warn("Failed to update URL:", error);
    }
    
    this.toaster("Game created! Share the invite link below.", "success", 4000);
  });

  // FIXED: Handle incoming connections properly
  this.peer.on("connection", (incomingConn) => {
    console.log("Incoming connection from:", incomingConn.peer);
  
  incomingConn.on("open", () => {
    this.conn = incomingConn;
    this.setupConnection();
    this.toaster("Player joined the game! You are X, they are O.", "success", 4000);
    
    const modal = document.getElementById("multiplayer-modal");
    if (modal && modal.open) {
      modal.close();
    }
  });
  });

  // Handle peer errors
  this.peer.on("error", (err) => {
    console.error("Peer creation error:", err);
    this.handleConnectionFailure("Failed to create game: " + (err.message || 'Unknown error'), err);
  });

  // Handle peer disconnection
  this.peer.on("disconnected", () => {
    console.log("Peer disconnected from signaling server");
    
    if (this.peer && !this.peer.destroyed) {
      console.log("Attempting to reconnect to signaling server...");
      this.peer.reconnect();
    }
  });
},








            isPowerUpDisabled(powerUpType) {
              // Game is over
              if (this.gameOver) return true;



      


                  // NEW: Only allow power-ups during opponent's turn
  if (this.gameMode === "multiplayer" && this.isMyTurn) {
    return true; // Disable power-ups during your own turn
  }
  
  // For AI mode, only allow during AI's turn
  if (this.gameMode === "ai" && this.currentPlayer === "X") {
    return true; // Disable during human player's turn
  }

              // Check specific power-up conditions
              switch (powerUpType) {
                case "undo":
                  return (
                    this.hasUsedUndo[this.currentPlayer] ||
                    this.moveHistory.length === 0
                  );
                case "swap":
                  return (
                    this.hasUsedSwap[this.currentPlayer] ||
                    this.cells.filter((cell) => cell !== null).length < 2
                  );
                case "remove":
                  if (this.hasUsedRemove[this.currentPlayer]) return true;
                  if (this.isMultiplayer) {
                    const opponent = this.currentPlayer === "X" ? "O" : "X";
                    return !this.cells.some((cell) => cell === opponent);
                  } else {
                    return !this.cells.some((cell) => cell !== null);
                  }

                case "expand":
                  return (
                    this.hasUsedExpand[this.currentPlayer] ||
                    this.gridRows === 6
                  );
                case "slide":
                  if (this.hasUsedSlide[this.currentPlayer]) return true;
                  try {
                    return !this.cells.some((cell, index) => {
                      if (cell !== this.currentPlayer) return false;
                      const slideCount = this.getValidSlideCount(index);
                      return slideCount > 0;
                    });
                  } catch (error) {
                    console.warn("Error checking slide validity:", error);
                    return true; // Disable if there's an error
                  }
                case "shield":
                  return (
                    this.hasUsedShield[this.currentPlayer] ||
                    !this.cells.some((cell) => cell === this.currentPlayer)
                  );
                case "teleport":
                  return (
                    this.hasUsedTeleport[this.currentPlayer] ||
                    !this.cells.some((cell) => cell === this.currentPlayer) ||
                    this.cells.filter((cell) => cell === null).length === 0
                  );
                default:
                  return false;
              }
            },

            // FIXED VERSION - Make them consistent:
            canMakeMoveAtIndex(index) {
              if (this.cells[index]) return false;
              if (this.gameOver) return false;

              if (this.gameMode === "ai") {
                // In AI mode, only allow human player to click UI buttons
                // AI moves are handled programmatically
                return this.currentPlayer === "X" && !this.aiThinking;
              }

              return this.isMyTurn;
            },

            canMakeMove(index) {
              if (this.cells[index]) return false;
              if (this.gameOver) return false;

              if (this.gameMode === "ai") {
                // Allow both players to make moves programmatically
                return true;
              }

              return this.isMyTurn;
            },
            toggleAI() {
              if (this.gameMode === "ai") {
                this.setGameMode("offline");
              } else {
                this.setGameMode("ai");
              }
            },
            setGameMode(mode) {
              // Clean up previous mode
              this.cleanupCurrentMode();

              // Set new mode
              this.gameMode = mode;

              switch (mode) {
                case "offline":
                  this.setupOfflineMode();
                  break;
                case "ai":
                  this.setupAIMode();
                  break;
                case "multiplayer":
                  this.setupMultiplayerMode();
                  break;
              }

              this.resetGame(false);
            },
          cleanupCurrentMode() {
  // Store peerIdToConnect if we're trying to join a game
  const preservePeerIdToConnect = this.peerIdToConnect && !this.isHost;
  
  // Clear any pending AI timeouts
  if (this.aiMoveTimeout) {
    clearTimeout(this.aiMoveTimeout);
    this.aiMoveTimeout = null;
  }

  // Stop AI if running
  if (this.gameMode === "ai") {
    this.aiThinking = false;
    this.aiPersonality = null;
  }

  // Disconnect multiplayer if connected
  if (this.gameMode === "multiplayer" && this.conn) {
    this.conn.close();
    this.conn = null;
  }

  if (this.peer) {
    this.peer.destroy();
    this.peer = null;
  }

  // Only clear peer IDs if we're not trying to join
  if (!preservePeerIdToConnect) {
    this.peerId = "";
    this.peerIdToConnect = "";
  }
  
  this.cleanUrl();
},

            setupOfflineMode() {
              this.isAIMode = false;
              this.toaster(
                "👥 Local play mode - pass the device!",
                "info",
                2000,
              );
            },

            setupAIMode() {
              this.isAIMode = true;
              this.aiPlayer = "O";
              this.generateAIPersonality();
              console.log("AI mode setup - AI is player:", this.aiPlayer);
              this.toaster(
                `🤖 AI opponent ready! Difficulty: ${this.getAIDifficultyName()}`,
                "success",
                3000,
              );
            },
            setupMultiplayerMode() {
              this.isAIMode = false;
              this.showMultiplayerModal();
            },
            startAIGame() {
              this.setGameMode("ai");

              // Close multiplayer modal if open
              const modal = document.getElementById("multiplayer-modal");
              if (modal && modal.open) {
                modal.close();
              }
            },

            stopAIGame() {
              this.setGameMode("offline");
            },

            setAIDifficulty(difficulty) {
              this.aiDifficulty = difficulty;
              if (this.gameMode === "ai") {
                this.generateAIPersonality();
                this.toaster(
                  `🎯 AI difficulty set to ${this.getAIDifficultyName()}`,
                  "info",
                  2000,
                );
              }
            },

            generateAIPersonality() {
              // Randomize AI skills for this game
              const skillVariation = 0.4; // How much skills can vary

              if (this.aiDifficulty === "random") {
                // Completely random personality
                this.aiSkills = {
                  strategicThinking: Math.random(),
                  powerUpTiming: Math.random(),
                  defensivePlay: Math.random(),
                  riskTaking: Math.random(),
                  adaptability: Math.random(),
                };
              } else {
                // Base skills on difficulty with some randomization
                const baseSkills = {
                  easy: 0.3,
                  medium: 0.6,
                  hard: 0.8,
                };

                const base = baseSkills[this.aiDifficulty] || 0.5;

                Object.keys(this.aiSkills).forEach((skill) => {
                  this.aiSkills[skill] = Math.max(
                    0.1,
                    Math.min(
                      0.9,
                      base + (Math.random() - 0.5) * skillVariation,
                    ),
                  );
                });
              }

              // Generate personality description
              this.aiPersonality = this.generatePersonalityDescription();
              console.log("AI Personality:", this.aiPersonality);
            },
            generatePersonalityDescription() {
              const traits = [];

              if (this.aiSkills.strategicThinking > 0.7)
                traits.push("Strategic");
              else if (this.aiSkills.strategicThinking < 0.3)
                traits.push("Impulsive");

              if (this.aiSkills.defensivePlay > 0.7) traits.push("Defensive");
              else if (this.aiSkills.defensivePlay < 0.3)
                traits.push("Aggressive");

              if (this.aiSkills.riskTaking > 0.7) traits.push("Bold");
              else if (this.aiSkills.riskTaking < 0.3) traits.push("Cautious");

              if (this.aiSkills.powerUpTiming > 0.7) traits.push("Tactical");

              return traits.join(", ") || "Balanced";
            },

            getAIDifficultyName() {
              const names = {
                easy: "Novice",
                medium: "Skilled",
                hard: "Expert",
                random: "Unpredictable",
              };
              return names[this.aiDifficulty] || "Unknown";
            },

            // ===== AI DECISION MAKING =====

           // Fixed makeAIMove with better error handling
makeAIMove() {
  if (!this.aiShouldMove || this.aiThinking || this.gameOver) {
    console.log("AI move skipped:", { 
      aiShouldMove: this.aiShouldMove, 
      aiThinking: this.aiThinking, 
      gameOver: this.gameOver 
    });
    return;
  }

  console.log("AI starting move process");
  this.aiThinking = true;
  
  const delay = this.getAIThinkingDelay();
  
  // Clear any existing timeout
  if (this.aiMoveTimeout) {
    clearTimeout(this.aiMoveTimeout);
  }
  
  this.aiMoveTimeout = setTimeout(() => {
    try {
      // Double-check conditions before making move
      if (!this.aiShouldMove || this.gameOver) {
        console.log("AI move cancelled - game state changed");
        return;
      }
      
      // Decide whether to use power-up or make regular move
      if (this.shouldAIUsePowerUp()) {
        this.executeAIPowerUp();
      } else {
        this.makeAIRegularMove();
      }
      
    } catch (error) {
      console.error("AI move error:", error);
      // Fallback to random move
      try {
        this.makeRandomMove();
      } catch (fallbackError) {
        console.error("AI fallback move failed:", fallbackError);
      }
    } finally {
      this.aiThinking = false;
      this.aiMoveTimeout = null;
    }
  }, delay);
},
canAIMakeMove() {
  return this.gameMode === 'ai' && 
         this.currentPlayer === this.aiPlayer && 
         !this.gameOver && 
         !this.aiThinking &&
         this.cells.some(cell => cell === null);
},
            getAIThinkingDelay() {
              const range =
                this.aiDelayRanges[this.aiDifficulty] ||
                this.aiDelayRanges.random;
              return Math.random() * (range[1] - range[0]) + range[0];
            },

            shouldAIUsePowerUp() {
              // Check if AI has any power-ups available
              const availablePowerUps = this.getAvailableAIPowerUps();
              if (availablePowerUps.length === 0) return false;

              // AI decides based on power-up timing skill and game state
              const urgency = this.calculateGameUrgency();
              const timingSkill = this.aiSkills.powerUpTiming;

              // Higher urgency + better timing skill = more likely to use power-up
              const usePowerUpChance =
                (urgency * 0.6 + timingSkill * 0.4) * 0.3;

              return Math.random() < usePowerUpChance;
            },

            calculateGameUrgency() {
              // Calculate how urgent the game situation is (0-1)
              let urgency = 0;

              // Check if player is about to win
              if (this.canPlayerWinNextMove("X")) {
                urgency += 0.8;
              }

              // Check if AI can win
              if (this.canPlayerWinNextMove(this.aiPlayer)) {
                urgency += 0.6;
              }

              // Check board fullness
              const filledSquares = this.cells.filter(
                (cell) => cell !== null,
              ).length;
              const totalSquares = this.gridRows * 4;
              urgency += (filledSquares / totalSquares) * 0.4;

              return Math.min(1, urgency);
            },

            getAvailableAIPowerUps() {
              const powerUps = [];

              if (
                !this.hasUsedUndo[this.aiPlayer] &&
                this.moveHistory.length > 0
              ) {
                powerUps.push("undo");
              }

              if (
                !this.hasUsedRemove[this.aiPlayer] &&
                this.cells.some((cell) => cell === "X")
              ) {
                powerUps.push("remove");
              }

              if (
                !this.hasUsedSwap[this.aiPlayer] &&
                this.cells.filter((cell) => cell !== null).length >= 2
              ) {
                powerUps.push("swap");
              }

              if (!this.hasUsedExpand[this.aiPlayer] && this.gridRows < 6) {
                powerUps.push("expand");
              }

              if (
                !this.hasUsedSlide[this.aiPlayer] &&
                this.hasValidAISlideMove()
              ) {
                powerUps.push("slide");
              }

              if (
                !this.hasUsedShield[this.aiPlayer] &&
                this.cells.some((cell) => cell === this.aiPlayer)
              ) {
                powerUps.push("shield");
              }

              if (
                !this.hasUsedTeleport[this.aiPlayer] &&
                this.cells.some((cell) => cell === this.aiPlayer) &&
                this.cells.filter((cell) => cell === null).length > 0
              ) {
                powerUps.push("teleport");
              }

              return powerUps;
            },

            hasValidAISlideMove() {
              return this.cells.some(
                (cell, index) =>
                  cell === this.aiPlayer && this.getValidSlideCount(index) > 0,
              );
            },
            // ===== AI POWER-UP EXECUTION =====

            executeAIPowerUp() {
              const availablePowerUps = this.getAvailableAIPowerUps();
              if (availablePowerUps.length === 0) {
                this.makeAIRegularMove();
                return;
              }

              // Choose power-up based on AI personality and game state
              const chosenPowerUp = this.chooseAIPowerUp(availablePowerUps);

              this.toaster(
                `🤖 AI is using ${chosenPowerUp}...`,
                "warning",
                2000,
              );

              switch (chosenPowerUp) {
                case "undo":
                  this.executeAIUndo();
                  break;
                case "remove":
                  this.executeAIRemove();
                  break;
                case "swap":
                  this.executeAISwap();
                  break;
                case "expand":
                  this.executeAIExpand();
                  break;
                case "slide":
                  this.executeAISlide();
                  break;
                case "shield":
                  this.executeAIShield();
                  break;
                case "teleport":
                  this.executeAITeleport();
                  break;
                default:
                  this.makeAIRegularMove();
              }
            },

            chooseAIPowerUp(availablePowerUps) {
              // Weight power-ups based on AI personality and game state
              const weights = {};

              availablePowerUps.forEach((powerUp) => {
                weights[powerUp] = this.calculatePowerUpWeight(powerUp);
              });

              // Choose weighted random power-up
              return this.weightedRandomChoice(weights);
            },
            calculatePowerUpWeight(powerUp) {
              let weight = 1;

              switch (powerUp) {
                case "undo":
                  // Defensive AIs use undo more
                  weight *= 1 + this.aiSkills.defensivePlay;
                  break;

                case "remove":
                  // Aggressive AIs use remove more, especially if player is threatening
                  weight *= 1 + (1 - this.aiSkills.defensivePlay);
                  if (this.canPlayerWinNextMove("X")) weight *= 3;
                  break;

                case "swap":
                  // Strategic AIs use swap more
                  weight *= 1 + this.aiSkills.strategicThinking;
                  break;

                case "expand":
                  // Risk-taking AIs expand more when behind
                  const aiAdvantage = this.calculatePositionAdvantage(
                    this.aiPlayer,
                  );
                  if (aiAdvantage < 0) weight *= 1 + this.aiSkills.riskTaking;
                  break;

                case "slide":
                  // Tactical AIs use slide for positioning
                  weight *= 1 + this.aiSkills.powerUpTiming;
                  break;

                case "shield":
                  // Defensive AIs shield valuable pieces
                  weight *= 1 + this.aiSkills.defensivePlay;
                  break;

                case "teleport":
                  // Bold AIs teleport for surprise attacks
                  weight *= 1 + this.aiSkills.riskTaking;
                  if (this.canPlayerWinNextMove(this.aiPlayer)) weight *= 2;
                  break;
              }

              return weight;
            },

            weightedRandomChoice(weights) {
              const totalWeight = Object.values(weights).reduce(
                (sum, weight) => sum + weight,
                0,
              );
              let random = Math.random() * totalWeight;

              for (const [choice, weight] of Object.entries(weights)) {
                random -= weight;
                if (random <= 0) return choice;
              }

              return Object.keys(weights)[0]; // Fallback
            },

            executeAIUndo() {
              if (
                this.moveHistory.length > 0 &&
                !this.hasUsedUndo[this.aiPlayer]
              ) {
                this.undoMove();
              } else {
                this.makeAIRegularMove();
              }
            },

            executeAIRemove() {
              const playerPieces = this.cells
                .map((cell, index) => ({ cell, index }))
                .filter(({ cell }) => cell === "X");

              if (playerPieces.length === 0) {
                this.makeAIRegularMove();
                return;
              }

              // Prioritize removing pieces that threaten AI or help player win
              let targetIndex = this.findBestRemoveTarget(playerPieces);

              if (targetIndex === -1) {
                // Random selection as fallback
                targetIndex =
                  playerPieces[Math.floor(Math.random() * playerPieces.length)]
                    .index;
              }

              this.removeOpponentPiece(targetIndex);
            },

            findBestRemoveTarget(playerPieces) {
              // Look for pieces that are part of winning threats
              for (const { index } of playerPieces) {
                if (this.isPiecePartOfThreat(index, "X")) {
                  return index;
                }
              }

              // Look for pieces in strategic positions (center, corners)
              for (const { index } of playerPieces) {
                if (this.isStrategicPosition(index)) {
                  return index;
                }
              }

              return -1;
            },

            executeAISwap() {
              const allPieces = this.cells
                .map((cell, index) => ({ cell, index }))
                .filter(({ cell }) => cell !== null);

              if (allPieces.length < 2) {
                this.makeAIRegularMove();
                return;
              }

              // Find best swap combination
              const bestSwap = this.findBestSwapMove(allPieces);

              if (bestSwap) {
                this.swapSelection = [bestSwap.index1, bestSwap.index2];
                this.performSwap();
              } else {
                this.makeAIRegularMove();
              }
            },
            findBestSwapMove(pieces) {
              let bestMove = null;
              let bestScore = -Infinity;

              for (let i = 0; i < pieces.length; i++) {
                for (let j = i + 1; j < pieces.length; j++) {
                  const score = this.evaluateSwapMove(
                    pieces[i].index,
                    pieces[j].index,
                  );
                  if (score > bestScore) {
                    bestScore = score;
                    bestMove = {
                      index1: pieces[i].index,
                      index2: pieces[j].index,
                    };
                  }
                }
              }

              return bestMove;
            },
            evaluateSwapMove(index1, index2) {
              // Simulate the swap and evaluate the resulting position
              const originalCell1 = this.cells[index1];
              const originalCell2 = this.cells[index2];

              // Temporarily perform swap
              this.cells[index1] = originalCell2;
              this.cells[index2] = originalCell1;

              const score = this.evaluatePosition(this.aiPlayer);

              // Restore original position
              this.cells[index1] = originalCell1;
              this.cells[index2] = originalCell2;

              return score;
            },

            executeAIExpand() {
              if (!this.hasUsedExpand[this.aiPlayer] && this.gridRows < 6) {
                this.expandGrid();
              } else {
                this.makeAIRegularMove();
              }
            },
            executeAISlide() {
              const aiPieces = this.cells
                .map((cell, index) => ({ cell, index }))
                .filter(
                  ({ cell, index }) =>
                    cell === this.aiPlayer &&
                    this.getValidSlideCount(index) > 0,
                );

              if (aiPieces.length === 0) {
                this.makeAIRegularMove();
                return;
              }

              const bestSlide = this.findBestSlideMove(aiPieces);

              if (bestSlide) {
                this.slideSelection = [bestSlide.fromIndex];
                this.slideMode = "destination";
                this.performSlide(bestSlide.toIndex);
              } else {
                this.makeAIRegularMove();
              }
            },
            findBestSlideMove(pieces) {
              let bestMove = null;
              let bestScore = -Infinity;

              for (const { index } of pieces) {
                const destinations = this.getSlideDestinationsForIndex(index);

                for (const destIndex of destinations) {
                  const score = this.evaluateSlideMove(index, destIndex);
                  if (score > bestScore) {
                    bestScore = score;
                    bestMove = { fromIndex: index, toIndex: destIndex };
                  }
                }
              }

              return bestMove;
            },

            getSlideDestinationsForIndex(index) {
              const row = Math.floor(index / 4);
              const col = index % 4;
              const destinations = [];

              const directions = [
                [-1, -1],
                [-1, 0],
                [-1, 1],
                [0, -1],
                [0, 1],
                [1, -1],
                [1, 0],
                [1, 1],
              ];

              directions.forEach(([deltaRow, deltaCol]) => {
                const newRow = row + deltaRow;
                const newCol = col + deltaCol;
                const newIndex = newRow * 4 + newCol;

                if (
                  newRow >= 0 &&
                  newRow < this.gridRows &&
                  newCol >= 0 &&
                  newCol < 4 &&
                  newIndex >= 0 &&
                  newIndex < this.cells.length &&
                  this.cells[newIndex] === null
                ) {
                  destinations.push(newIndex);
                }
              });

              return destinations;
            },

            evaluateSlideMove(fromIndex, toIndex) {
              // Temporarily perform slide
              const originalPiece = this.cells[fromIndex];
              this.cells[fromIndex] = null;
              this.cells[toIndex] = originalPiece;

              const score = this.evaluatePosition(this.aiPlayer);

              // Restore original position
              this.cells[fromIndex] = originalPiece;
              this.cells[toIndex] = null;

              return score;
            },

            executeAIShield() {
              const aiPieces = this.cells
                .map((cell, index) => ({ cell, index }))
                .filter(
                  ({ cell, index }) =>
                    cell === this.aiPlayer && !this.shieldedSquares[index],
                );

              if (aiPieces.length === 0) {
                this.makeAIRegularMove();
                return;
              }

              // Find most valuable piece to shield
              let bestPiece = null;
              let bestValue = -1;

              for (const { index } of aiPieces) {
                const value = this.calculatePieceValue(index, this.aiPlayer);
                if (value > bestValue) {
                  bestValue = value;
                  bestPiece = index;
                }
              }

              if (bestPiece !== null) {
                this.shieldPiece(bestPiece);
              } else {
                this.makeAIRegularMove();
              }
            },

            executeAITeleport() {
              const aiPieces = this.cells
                .map((cell, index) => ({ cell, index }))
                .filter(({ cell }) => cell === this.aiPlayer);

              const emptySquares = this.cells
                .map((cell, index) => ({ cell, index }))
                .filter(({ cell }) => cell === null);

              if (aiPieces.length === 0 || emptySquares.length === 0) {
                this.makeAIRegularMove();
                return;
              }

              const bestTeleport = this.findBestTeleportMove(
                aiPieces,
                emptySquares,
              );

              if (bestTeleport) {
                this.teleportSelection = [bestTeleport.fromIndex];
                this.performTeleport(bestTeleport.toIndex);
              } else {
                this.makeAIRegularMove();
              }
            },

            findBestTeleportMove(pieces, emptySquares) {
              let bestMove = null;
              let bestScore = -Infinity;

              for (const { index: fromIndex } of pieces) {
                for (const { index: toIndex } of emptySquares) {
                  const score = this.evaluateTeleportMove(fromIndex, toIndex);
                  if (score > bestScore) {
                    bestScore = score;
                    bestMove = { fromIndex, toIndex };
                  }
                }
              }

              return bestMove;
            },
            evaluateTeleportMove(fromIndex, toIndex) {
              // Temporarily perform teleport
              const originalPiece = this.cells[fromIndex];
              this.cells[fromIndex] = null;
              this.cells[toIndex] = originalPiece;

              const score = this.evaluatePosition(this.aiPlayer);

              // Restore original position
              this.cells[fromIndex] = originalPiece;
              this.cells[toIndex] = null;

              return score;
            },

            // ===== AI REGULAR MOVE =====

            makeAIRegularMove() {
              const emptySquares = this.cells
                .map((cell, index) => ({ cell, index }))
                .filter(({ cell }) => cell === null);

              if (emptySquares.length === 0) return;

              let chosenIndex;

              // Check if AI can win immediately
              const winningMove = this.findWinningMove(this.aiPlayer);
              if (winningMove !== -1) {
                chosenIndex = winningMove;
              }
              // Check if AI needs to block player from winning
              else if (this.aiSkills.defensivePlay > 0.3) {
                const blockingMove = this.findWinningMove("X");
                if (blockingMove !== -1) {
                  chosenIndex = blockingMove;
                }
              }

              // If no immediate win/block, use strategic move
              if (chosenIndex === undefined) {
                chosenIndex = this.findBestStrategicMove(emptySquares);
              }

              // Fallback to random move
              if (
                chosenIndex === undefined ||
                this.cells[chosenIndex] !== null
              ) {
                chosenIndex =
                  emptySquares[Math.floor(Math.random() * emptySquares.length)]
                    .index;
              }

              this.makeMove(chosenIndex);
            },

            findWinningMove(player) {
              for (let i = 0; i < this.cells.length; i++) {
                if (this.cells[i] === null) {
                  // Temporarily place piece
                  this.cells[i] = player;

                  // Check if this creates a win
                  const isWin = this.wouldCreateWin(i, player);

                  // Remove temporary piece
                  this.cells[i] = null;

                  if (isWin) return i;
                }
              }
              return -1;
            },

            wouldCreateWin(index, player) {
              // Check all possible winning combinations that include this index
              let wins = this.getWinningCombinations();

              for (let combo of wins) {
                if (combo.includes(index)) {
                  const [a, b, c] = combo;
                  if (
                    this.cells[a] === player &&
                    this.cells[b] === player &&
                    this.cells[c] === player
                  ) {
                    return true;
                  }
                }
              }
              return false;
            },

            findBestStrategicMove(emptySquares) {
              let bestMove = null;
              let bestScore = -Infinity;

              for (const { index } of emptySquares) {
                const score = this.evaluateMovePosition(index);

                // Add some randomness based on AI skill
                const randomFactor =
                  (1 - this.aiSkills.strategicThinking) * 0.3;
                const adjustedScore =
                  score + (Math.random() - 0.5) * randomFactor;

                if (adjustedScore > bestScore) {
                  bestScore = adjustedScore;
                  bestMove = index;
                }
              }

              return bestMove;
            },
            evaluateMovePosition(index) {
              // Temporarily place AI piece
              this.cells[index] = this.aiPlayer;

              const score = this.evaluatePosition(this.aiPlayer);

              // Remove temporary piece
              this.cells[index] = null;

              return score;
            },
            // ===== AI EVALUATION FUNCTIONS =====

            evaluatePosition(player) {
              let score = 0;

              // Evaluate winning opportunities
              score += this.countWinningOpportunities(player) * 10;
              score -=
                this.countWinningOpportunities(player === "X" ? "O" : "X") * 10;

              // Evaluate position control
              score += this.evaluatePositionControl(player) * 3;

              // Evaluate piece safety
              score += this.evaluatePieceSafety(player) * 2;

              return score;
            },

            countWinningOpportunities(player) {
              let opportunities = 0;
              const wins = this.getWinningCombinations();

              for (let combo of wins) {
                const [a, b, c] = combo;
                const playerCount = [
                  this.cells[a],
                  this.cells[b],
                  this.cells[c],
                ].filter((cell) => cell === player).length;
                const emptyCount = [
                  this.cells[a],
                  this.cells[b],
                  this.cells[c],
                ].filter((cell) => cell === null).length;
                const opponentCount = 3 - playerCount - emptyCount;

                if (opponentCount === 0) {
                  if (playerCount === 2 && emptyCount === 1)
                    opportunities += 3; // One move to win
                  else if (playerCount === 1 && emptyCount === 2)
                    opportunities += 1; // Two moves to win
                }
              }

              return opportunities;
            },

            evaluatePositionControl(player) {
              let control = 0;

              // Center positions are more valuable
              const centerPositions = this.getCenterPositions();
              for (const pos of centerPositions) {
                if (this.cells[pos] === player) control += 2;
              }

              // Corner positions
              const cornerPositions = this.getCornerPositions();
              for (const pos of cornerPositions) {
                if (this.cells[pos] === player) control += 1;
              }

              return control;
            },

            evaluatePieceSafety(player) {
              let safety = 0;

              for (let i = 0; i < this.cells.length; i++) {
                if (this.cells[i] === player) {
                  if (this.shieldedSquares[i]) safety += 2;
                  safety += this.calculatePieceValue(i, player);
                }
              }

              return safety;
            },

            calculatePieceValue(index, player) {
              // Calculate how valuable this piece is based on its position and threats
              let value = 0;

              // Strategic position value
              if (this.isStrategicPosition(index)) value += 2;

              // Part of potential winning combinations
              value += this.countPotentialWins(index, player);

              return value;
            },

            isStrategicPosition(index) {
              const centerPositions = this.getCenterPositions();
              const cornerPositions = this.getCornerPositions();

              return (
                centerPositions.includes(index) ||
                cornerPositions.includes(index)
              );
            },

            getCenterPositions() {
              // Return center positions based on current grid size
              const centers = [];
              if (this.gridRows >= 4) {
                centers.push(5, 6, 9, 10); // 4x4 centers
              }
              if (this.gridRows >= 5) {
                centers.push(13, 14); // 4x5 additional centers
              }
              if (this.gridRows >= 6) {
                centers.push(17, 18); // 4x6 additional centers
              }
              return centers.filter((pos) => pos < this.cells.length);
            },

            getCornerPositions() {
              const corners = [0, 3]; // Top corners
              corners.push(
                (this.gridRows - 1) * 4,
                (this.gridRows - 1) * 4 + 3,
              ); // Bottom corners
              return corners.filter((pos) => pos < this.cells.length);
            },

            countPotentialWins(index, player) {
              let count = 0;
              const wins = this.getWinningCombinations();

              for (let combo of wins) {
                if (combo.includes(index)) {
                  const [a, b, c] = combo;
                  const opponentCount = [
                    this.cells[a],
                    this.cells[b],
                    this.cells[c],
                  ].filter((cell) => cell !== null && cell !== player).length;

                  if (opponentCount === 0) count++;
                }
              }

              return count;
            },

            isPiecePartOfThreat(index, player) {
              const wins = this.getWinningCombinations();

              for (let combo of wins) {
                if (combo.includes(index)) {
                  const [a, b, c] = combo;
                  const playerCount = [
                    this.cells[a],
                    this.cells[b],
                    this.cells[c],
                  ].filter((cell) => cell === player).length;
                  const emptyCount = [
                    this.cells[a],
                    this.cells[b],
                    this.cells[c],
                  ].filter((cell) => cell === null).length;

                  if (playerCount >= 2 && emptyCount >= 1) return true;
                }
              }

              return false;
            },

            canPlayerWinNextMove(player) {
              return this.findWinningMove(player) !== -1;
            },

            calculatePositionAdvantage(player) {
              const playerScore = this.evaluatePosition(player);
              const opponentScore = this.evaluatePosition(
                player === "X" ? "O" : "X",
              );
              return playerScore - opponentScore;
            },

            getWinningCombinations() {
              // Return all possible winning combinations for current grid size
              let wins = [];

              if (this.gridRows === 4) {
                wins = [
                  [0, 1, 2],
                  [1, 2, 3],
                  [4, 5, 6],
                  [5, 6, 7],
                  [8, 9, 10],
                  [9, 10, 11],
                  [12, 13, 14],
                  [13, 14, 15],
                  [0, 4, 8],
                  [4, 8, 12],
                  [1, 5, 9],
                  [5, 9, 13],
                  [2, 6, 10],
                  [6, 10, 14],
                  [3, 7, 11],
                  [7, 11, 15],
                  [0, 5, 10],
                  [1, 6, 11],
                  [4, 9, 14],
                  [5, 10, 15],
                  [2, 5, 8],
                  [3, 6, 9],
                  [6, 9, 12],
                  [7, 10, 13],
                ];
              } else {
                // Dynamic calculation for expanded grids
                wins = [];

                // Horizontal wins
                for (let row = 0; row < this.gridRows; row++) {
                  for (let col = 0; col <= 1; col++) {
                    const start = row * 4 + col;
                    wins.push([start, start + 1, start + 2]);
                  }
                }

                // Vertical wins
                for (let col = 0; col < 4; col++) {
                  for (let row = 0; row <= this.gridRows - 3; row++) {
                    const start = row * 4 + col;
                    wins.push([start, start + 4, start + 8]);
                  }
                }

                // Diagonal wins (top-left to bottom-right)
                for (let row = 0; row <= this.gridRows - 3; row++) {
                  for (let col = 0; col <= 1; col++) {
                    const start = row * 4 + col;
                    wins.push([start, start + 5, start + 10]);
                  }
                }

                // Diagonal wins (top-right to bottom-left)
                for (let row = 0; row <= this.gridRows - 3; row++) {
                  for (let col = 2; col <= 3; col++) {
                    const start = row * 4 + col;
                    wins.push([start, start + 3, start + 6]);
                  }
                }
              }

              return wins;
            },

            // ===== UTILITY FUNCTIONS =====

            makeRandomMove() {
              const emptySquares = this.cells
                .map((cell, index) => ({ cell, index }))
                .filter(({ cell }) => cell === null);

              if (emptySquares.length > 0) {
                const randomIndex = Math.floor(
                  Math.random() * emptySquares.length,
                );
                this.makeMove(emptySquares[randomIndex].index);
              }
            },
            // Enhanced accessibility methods
            getCellAriaLabel(index, cell) {
              const row = Math.floor(index / 4) + 1;
              const col = (index % 4) + 1;
              const position = `Row ${row}, Column ${col}`;

              if (cell) {
                const player = cell === "X" ? "Player X" : "Player O";
                const emoji = this.getEmoji(cell);
                return `${position}, occupied by ${player} ${emoji}`;
              } else if (this.isMyTurn && !this.gameOver) {
                return `${position}, empty cell, click to place your piece`;
              } else {
                return `${position}, empty cell`;
              }
            },

            getTabIndex(index) {
              if (this.gameOver || !this.isMyTurn) return -1;
              return index === this.focusedCellIndex ? 0 : -1;
            },

            announceGameState(message) {
              this.gameAnnouncement = message;
              setTimeout(() => {
                this.gameAnnouncement = "";
              }, 3000);
            },

            // Keyboard navigation
            setupKeyboardNavigation() {
              document.addEventListener("keydown", this.handleKeyDown);
            },

            handleKeyDown(event) {
              if (!this.isMyTurn || this.gameOver) return;

              const currentRow = Math.floor(this.focusedCellIndex / 4);
              const currentCol = this.focusedCellIndex % 4;
              let newIndex = this.focusedCellIndex;

              switch (event.key) {
                case "ArrowRight":
                  event.preventDefault();
                  if (currentCol < 3) newIndex = this.focusedCellIndex + 1;
                  break;
                case "ArrowLeft":
                  event.preventDefault();
                  if (currentCol > 0) newIndex = this.focusedCellIndex - 1;
                  break;
                case "ArrowDown":
                  event.preventDefault();
                  if (currentRow < this.gridRows - 1)
                    newIndex = this.focusedCellIndex + 4;
                  break;
                case "ArrowUp":
                  event.preventDefault();
                  if (currentRow > 0) newIndex = this.focusedCellIndex - 4;
                  break;
                case "Enter":
                case " ":
                  event.preventDefault();
                  if (!this.cells[this.focusedCellIndex]) {
                    this.makeMove(this.focusedCellIndex);
                  }
                  break;
                case "Home":
                  event.preventDefault();
                  newIndex = 0;
                  break;
                case "End":
                  event.preventDefault();
                  newIndex = this.gridRows * 4 - 1;
                  break;
              }

              if (newIndex !== this.focusedCellIndex) {
                this.focusedCellIndex = newIndex;
                this.focusCell(newIndex);
              }
            },

            focusCell(index) {
              const gameButtons =
                document.querySelectorAll('[role="gridcell"]');
              if (gameButtons[index]) {
                gameButtons[index].focus();
              }
            },

            // Enhanced performance methods
            debouncedFlashSquare: debounce(function (index) {
              this.flashSquare(index);
            }, 100),

            throttledToaster: throttle(function (message, type, duration) {
              this.toaster(message, type, duration);
            }, 1000),

            // Game logic methods
            getValidSlideCount(index) {
              if (index < 0 || index >= this.cells.length) return 0;
              if (this.cells[index] !== this.currentPlayer) return 0;

              const row = Math.floor(index / 4);
              const col = index % 4;
              let count = 0;

              const directions = [
                [-1, -1],
                [-1, 0],
                [-1, 1],
                [0, -1],
                [0, 1],
                [1, -1],
                [1, 0],
                [1, 1],
              ];

              directions.forEach(([deltaRow, deltaCol]) => {
                const newRow = row + deltaRow;
                const newCol = col + deltaCol;
                const newIndex = newRow * 4 + newCol;

                if (
                  newRow >= 0 &&
                  newRow < this.gridRows &&
                  newCol >= 0 &&
                  newCol < 4 &&
                  newIndex >= 0 &&
                  newIndex < this.cells.length &&
                  this.cells[newIndex] === null
                ) {
                  count++;
                }
              });

              return count;
            },

            hasValidSlideMove() {
              return this.cells.some(
                (cell, index) =>
                  cell === this.currentPlayer &&
                  this.getValidSlideCount(index) > 0,
              );
            },

            showSlidePowerModal() {
              try {
                this.slideSelection = [];
                this.slideMode = "select";
                document.getElementById("slide-modal").showModal();
              } catch (error) {
                this.handleError("Show slide modal", error);
              }
            },

            performSlide(destinationIndex) {
              try {
                if (this.slideSelection.length !== 1) return;

                const sourceIndex = this.slideSelection[0];
                const validDestinations = this.getSlideDestinations;
                if (!validDestinations.includes(destinationIndex)) {
                  this.toaster("Invalid slide destination!", "error");
                  return;
                }

                this.flashSquare(sourceIndex);
                this.flashSquare(destinationIndex);

                this.cells[destinationIndex] = this.cells[sourceIndex];
                this.cells[sourceIndex] = null;

                if (this.shieldedSquares[sourceIndex]) {
                  this.shieldedSquares[sourceIndex] = false;
                  this.shieldedSquares[destinationIndex] = true;
                }

                this.hasUsedSlide[this.currentPlayer] = true;
                document.getElementById("slide-modal").close();
                this.resetSlideSelection();

                this.toaster(
                  `${this.getEmoji(this.currentPlayer)} slid a piece!`,
                  "info",
                );

                this.checkGameState();

                if (!this.winner && !this.isDraw) {
                  this.switchTurn();
                }

                if (this.conn && this.conn.open) {
                  this.conn.send({
                    type: "slide",
                    cells: [...this.cells],
                    currentPlayer: this.currentPlayer,
                    hasUsedSlide: { ...this.hasUsedSlide },
                    shieldedSquares: [...this.shieldedSquares],
                    winner: this.winner,
                    isDraw: this.isDraw,
                    winningCombo: [...this.winningCombo],
                  });
                }
              } catch (error) {
                this.handleError("Slide piece", error);
              }
            },

            resetSlideSelection() {
              this.slideSelection = [];
              this.slideMode = "select";
            },

            showShieldPowerModal() {
              try {
                document.getElementById("shield-modal").showModal();
              } catch (error) {
                this.handleError("Show shield modal", error);
              }
            },

            shieldPiece(index) {
              try {
                if (this.hasUsedShield[this.currentPlayer]) return;
                if (this.cells[index] !== this.currentPlayer) return;

                this.flashSquare(index);
                this.shieldedSquares[index] = true;
                this.hasUsedShield[this.currentPlayer] = true;

                document.getElementById("shield-modal").close();

                this.toaster(
                  `${this.getEmoji(this.currentPlayer)} shielded a piece!`,
                  "success",
                );

                this.switchTurn();

                if (this.conn && this.conn.open) {
                  this.conn.send({
                    type: "shield",
                    currentPlayer: this.currentPlayer,
                    hasUsedShield: { ...this.hasUsedShield },
                    shieldedSquares: [...this.shieldedSquares],
                  });
                }
              } catch (error) {
                this.handleError("Shield piece", error);
              }
            },

            showTeleportPowerModal() {
              try {
                this.teleportSelection = [];
                document.getElementById("teleport-modal").showModal();
              } catch (error) {
                this.handleError("Show teleport modal", error);
              }
            },

            selectTeleportPiece(index) {
              if (this.teleportSelection.length === 0) {
                if (this.cells[index] === this.currentPlayer) {
                  this.teleportSelection = [index];
                }
              } else if (this.teleportSelection.length === 1) {
                if (this.cells[index] === null) {
                  this.performTeleport(index);
                }
              }
            },

            performTeleport(destinationIndex) {
              try {
                if (this.teleportSelection.length !== 1) return;

                const sourceIndex = this.teleportSelection[0];
                this.flashSquare(sourceIndex);
                this.flashSquare(destinationIndex);

                this.cells[destinationIndex] = this.cells[sourceIndex];
                this.cells[sourceIndex] = null;

                if (this.shieldedSquares[sourceIndex]) {
                  this.shieldedSquares[sourceIndex] = false;
                  this.shieldedSquares[destinationIndex] = true;
                }

                this.hasUsedTeleport[this.currentPlayer] = true;
                document.getElementById("teleport-modal").close();
                this.resetTeleportSelection();

                this.toaster(
                  `${this.getEmoji(this.currentPlayer)} teleported a piece!`,
                  "warning",
                );

                this.checkGameState();

                if (!this.winner && !this.isDraw) {
                  this.switchTurn();
                }

                if (this.conn && this.conn.open) {
                  this.conn.send({
                    type: "teleport",
                    cells: [...this.cells],
                    currentPlayer: this.currentPlayer,
                    hasUsedTeleport: { ...this.hasUsedTeleport },
                    shieldedSquares: [...this.shieldedSquares],
                    winner: this.winner,
                    isDraw: this.isDraw,
                    winningCombo: [...this.winningCombo],
                  });
                }
              } catch (error) {
                this.handleError("Teleport piece", error);
              }
            },

            resetTeleportSelection() {
              this.teleportSelection = [];
            },

            selectSlidePiece(index) {
              if (this.slideMode === "select") {
                if (this.cells[index] === this.currentPlayer) {
                  this.slideSelection = [index];
                  this.slideMode = "destination";

                  const validDestinations = this.getSlideDestinations;
                  if (validDestinations.length === 0) {
                    this.toaster(
                      "This piece cannot slide - no adjacent empty squares!",
                      "warning",
                      3000,
                    );
                    this.resetSlideSelection();
                    return;
                  }
                }
              } else if (this.slideMode === "destination") {
                const validDestinations = this.getSlideDestinations;
                if (validDestinations.includes(index)) {
                  this.performSlide(index);
                } else {
                  if (this.cells[index] === this.currentPlayer) {
                    this.slideSelection = [index];
                    const newValidDestinations = this.getSlideDestinations;
                    if (newValidDestinations.length === 0) {
                      this.toaster(
                        "This piece cannot slide - no adjacent empty squares!",
                        "warning",
                        3000,
                      );
                      this.resetSlideSelection();
                    }
                  }
                }
              }
            },

            handleError(operation, error) {
              console.error(`Error in ${operation}:`, error);
              this.toaster(
                `${operation} failed: ${error.message || "Unknown error"}`,
                "error",
                4000,
              );
            },

            cleanUrl() {
              const url = new URL(window.location);
              url.searchParams.delete("gameId");
              window.history.replaceState({}, document.title, url.pathname);
            },

            handleConnectionFailure(message, error = null) {
              if (error) {
                console.error("Connection error:", error);
              }

              this.toaster(message, "error", 4000);

              if (this.peer) {
                try {
                  this.peer.destroy();
                } catch (e) {
                  console.warn("Error destroying peer:", e);
                }
                this.peer = null;
              }
              this.conn = null;
              this.peerId = "";
              this.peerIdToConnect = "";

              this.cleanUrl();
              const modal = document.getElementById("multiplayer-modal");
              if (modal && modal.open) {
                modal.close();
              }

              this.toaster("Switched to single player mode", "info", 3000);
            },

            switchTurn() {
              if (!this.winner && !this.isDraw) {
                this.currentPlayer = this.currentPlayer === "X" ? "O" : "X";
                if (!this.isMultiplayer || this.isMyTurn) {
                  this.toaster(
                    `${this.getEmoji(this.currentPlayer)}'s turn`,
                    "info",
                    1500,
                  );
                }
              }
            },

            expandGrid() {
              try {
                if (
                  this.hasUsedExpand[this.currentPlayer] ||
                  this.gridRows === 6 ||
                  this.gameOver
                )
                  return;

                this.isExpanding = true;
                this.hasUsedExpand[this.currentPlayer] = true;

                const newRowCount = this.gridRows + 1;
                const currentCellCount = this.gridRows * 4;
                const newCellCount = newRowCount * 4;

                // FIXED: Properly resize all arrays
                const newCells = Array(newCellCount).fill(null);
                const newShieldedSquares = Array(newCellCount).fill(false);
                const newSquareEffects = Array(newCellCount).fill(false);

                // Copy existing data
                for (let i = 0; i < currentCellCount; i++) {
                  newCells[i] = this.cells[i];
                  newShieldedSquares[i] = this.shieldedSquares[i];
                  newSquareEffects[i] = this.squareEffects[i];
                }

                this.cells = newCells;
                this.shieldedSquares = newShieldedSquares;
                this.squareEffects = newSquareEffects;
                this.gridRows = newRowCount;

                setTimeout(() => {
                  this.isExpanding = false;
                }, 800);

                this.toaster(
                  `${this.getEmoji(this.currentPlayer)} added row ${newRowCount}! Now ${4}×${newRowCount}`,
                  "warning",
                  3000,
                );

                this.switchTurn();

                if (this.conn && this.conn.open) {
                  this.conn.send({
                    type: "expand",
                    cells: [...this.cells],
                    gridRows: this.gridRows,
                    currentPlayer: this.currentPlayer,
                    hasUsedExpand: { ...this.hasUsedExpand },
                    shieldedSquares: [...this.shieldedSquares], // ADDED: Include shields
                  });
                }
              } catch (error) {
                this.handleError("Expand grid", error);
              }
            },

            flashSquare(index) {
              this.squareEffects[index] = true;
              setTimeout(() => {
                this.squareEffects[index] = false;
              }, 600);
            },

            shakeScreen() {
              if (this.isShaking) return;
              this.isShaking = true;
              document.body.classList.add("tilt-n-move-shaking");
              setTimeout(() => {
                document.body.classList.remove("tilt-n-move-shaking");
                this.isShaking = false;
              }, 500);
            },

            showMultiplayerModal() {
              document.getElementById("multiplayer-modal").showModal();
            },

            showAboutModal() {
              document.getElementById("about-modal").showModal();
            },

            showSwapPowerModal() {
              try {
                this.swapSelection = [];
                document.getElementById("swap-modal").showModal();
              } catch (error) {
                this.handleError("Show swap modal", error);
              }
            },

            selectSwapPiece(index) {
              if (this.cells[index] === null) return;

              if (this.swapSelection.includes(index)) {
                this.swapSelection = this.swapSelection.filter(
                  (i) => i !== index,
                );
              } else if (this.swapSelection.length < 2) {
                this.swapSelection.push(index);

                if (this.swapSelection.length === 2) {
                  this.performSwap();
                }
              }
            },

            performSwap() {
              try {
                if (this.swapSelection.length !== 2) return;

                const [index1, index2] = this.swapSelection;
                this.flashSquare(index1);
                this.flashSquare(index2);

                const temp = this.cells[index1];
                this.cells[index1] = this.cells[index2];
                this.cells[index2] = temp;

                const tempShield = this.shieldedSquares[index1];
                this.shieldedSquares[index1] = this.shieldedSquares[index2];
                this.shieldedSquares[index2] = tempShield;

                this.hasUsedSwap[this.currentPlayer] = true;

                document.getElementById("swap-modal").close();
                this.resetSwapSelection();

                this.toaster(
                  `${this.getEmoji(this.currentPlayer)} swapped two pieces!`,
                  "info",
                );

                this.checkGameState();

                if (!this.winner && !this.isDraw) {
                  this.switchTurn();
                }

                if (this.conn && this.conn.open) {
                  this.conn.send({
                    type: "swap",
                    cells: [...this.cells],
                    currentPlayer: this.currentPlayer,
                    hasUsedSwap: { ...this.hasUsedSwap },
                    shieldedSquares: [...this.shieldedSquares],
                    winner: this.winner,
                    isDraw: this.isDraw,
                    winningCombo: [...this.winningCombo],
                  });
                }
              } catch (error) {
                this.handleError("Swap pieces", error);
              }
            },

            resetSwapSelection() {
              this.swapSelection = [];
            },

            showRemovePowerModal() {
              try {
                document.getElementById("remove-modal").showModal();
              } catch (error) {
                this.handleError("Show remove modal", error);
              }
            },

            removeOpponentPiece(index) {
              try {
                this.flashSquare(index);
                const opponent = this.currentPlayer === "X" ? "O" : "X";
                if (this.hasUsedRemove[this.currentPlayer]) return;

                if (this.isMultiplayer && this.cells[index] !== opponent)
                  return;
                if (!this.isMultiplayer && this.cells[index] === null) return;

                if (this.shieldedSquares[index]) {
                  this.shieldedSquares[index] = false;
                  this.toaster("Shield blocked the removal!", "info");
                } else {
                  this.cells[index] = null;
                }

                this.hasUsedRemove[this.currentPlayer] = true;
                document.getElementById("remove-modal").close();

                this.toaster(
                  `${this.getEmoji(this.currentPlayer)} used remove!`,
                  "warning",
                );

                this.switchTurn();

                if (this.conn && this.conn.open) {
                  this.conn.send({
                    type: "remove",
                    cells: [...this.cells],
                    currentPlayer: this.currentPlayer,
                    hasUsedRemove: { ...this.hasUsedRemove },
                    shieldedSquares: [...this.shieldedSquares],
                  });
                }
              } catch (error) {
                this.handleError("Remove piece", error);
              }
            },

            undoMove() {
              try {
                const last = this.moveHistory.pop();
                if (!last || this.hasUsedUndo[this.currentPlayer]) return;

                this.flashSquare(last.index);
                this.cells[last.index] = null;
                this.winner = null;
                this.isDraw = false;
                this.winningCombo = [];
                this.hasUsedUndo[this.currentPlayer] = true;

                this.toaster(
                  `${this.getEmoji(this.currentPlayer)} undid their last move!`,
                  "warning",
                );

                this.switchTurn();

                if (this.conn && this.conn.open) {
                  this.conn.send({
                    type: "undo",
                    cells: [...this.cells],
                    currentPlayer: this.currentPlayer,
                    winner: this.winner,
                    isDraw: this.isDraw,
                    winningCombo: [...this.winningCombo],
                    moveHistory: [...this.moveHistory],
                    hasUsedUndo: { ...this.hasUsedUndo },
                  });
                }
              } catch (error) {
                this.handleError("Undo move", error);
              }
            },

            toaster(msg, type = "info", duration = 3000) {
              const colors = {
                info: "#3b82f6",
                success: "#10b981",
                warning: "#f59e0b",
                error: "#ef4444",
              };

              if (window.Toastify) {
                window
                  .Toastify({
                    text: msg,
                    duration: duration,
                    gravity: "bottom",
                    position: "right",
                    backgroundColor: colors[type],
                    className: "rounded-xl shadow-lg",
                    stopOnFocus: true,
                  })
                  .showToast();
              } else {
                console.log(`Toast [${type}]: ${msg}`);
              }
            },

            getEmoji(val) {
              return this.emojiSet[val] || " ";
            },

            toggleEmojiTheme() {
              this.themeIndex = (this.themeIndex + 1) % this.emojiThemes.length;
              this.toaster(
                `Theme changed to ${this.emojiSet.X} vs ${this.emojiSet.O}!`,
                "info",
              );
            },

  
setupConnection() {
  if (!this.conn) {
    console.error("setupConnection called but no connection exists");
    return;
  }

  console.log("Setting up connection data handlers...");

  // FIXED: Only set up data handler, connection state is already handled
  this.conn.on("data", (data) => {
    try {
      console.log("Received data:", data);

      if (!data || typeof data !== "object") {
        console.error("Invalid data received:", data);
        return;
      }

      // Handle different message types
      this.handleIncomingMessage(data);
      
    } catch (error) {
      console.error("Error processing received data:", error);
      this.toaster("Error syncing with opponent", "error");
    }
  });

  // FIXED: Don't re-add close/error handlers if they're already set
  if (!this.conn._events || !this.conn._events.close) {
    this.conn.on("close", () => {
      console.log("Connection closed");
      this.toaster("Opponent disconnected", "error");
      this.conn = null;
      this.setGameMode("offline");
    });
  }

  if (!this.conn._events || !this.conn._events.error) {
    this.conn.on("error", (err) => {
      console.error("Connection error:", err);
      this.toaster("Connection error: " + (err.message || 'Unknown error'), "error");
      this.conn = null;
      this.setGameMode("offline");
    });
  }
},



// Helper method to validate incoming game data
isValidGameData(data) {
  if (!data || typeof data !== 'object') return false;
  
  // Check required fields based on message type
  switch (data.type) {
    case 'move':
      return Array.isArray(data.cells) && 
             typeof data.currentPlayer === 'string' &&
             data.cells.length === (data.gridRows || this.gridRows) * 4;
    case 'reset':
    case 'requestSync':
      return true; // These messages don't need additional validation
    case 'slide':
    case 'teleport':
    case 'swap':
      return Array.isArray(data.cells) && data.cells.length > 0;
    case 'shield':
    case 'undo':
    case 'remove':
    case 'expand':
      return typeof data.currentPlayer === 'string';
    default:
      return data.type && typeof data.type === 'string';
  }
},

// Centralized message handler
handleIncomingMessage(data) {
  switch (data.type) {
    case "move":
      this.handleMoveData(data);
      break;
    case "slide":
      this.handleSlideData(data);
      break;
    case "shield":
      this.handleShieldData(data);
      break;
    case "teleport":
      this.handleTeleportData(data);
      break;
    case "reset":
      this.resetGame(false);
      this.toaster("Opponent started a new game!", "info");
      break;
    case "undo":
      this.handleUndoData(data);
      break;
    case "remove":
      this.handleRemoveData(data);
      break;
    case "swap":
      this.handleSwapData(data);
      break;
    case "expand":
      this.handleExpandData(data);
      break;
    case "requestSync":
      // Send current game state
      this.sendGameSync();
      break;
    case "gameSync":
      // Handle full game state sync
      this.handleGameSync(data);
      break;
    case "disconnect":
      this.toaster(`Opponent disconnected: ${data.reason || 'Unknown reason'}`, "warning");
      this.setGameMode("offline");
      break;
    default:
      console.warn("Unknown message type:", data.type);
  }
},

// Handle full game state synchronization
handleGameSync(data) {
  console.log("Receiving full game sync");
  
  try {
    // Update all game state from sync data
    this.cells = [...data.cells];
    this.gridRows = data.gridRows || 4;
    this.currentPlayer = data.currentPlayer;
    this.winner = data.winner;
    this.isDraw = data.isDraw;
    this.winningCombo = [...(data.winningCombo || [])];
    this.score = { ...data.score };
    this.moveHistory = [...(data.moveHistory || [])];
    
    // Update all power-up states
    this.hasUsedUndo = { ...data.hasUsedUndo };
    this.hasUsedRemove = { ...data.hasUsedRemove };
    this.hasUsedSwap = { ...data.hasUsedSwap };
    this.hasUsedExpand = { ...data.hasUsedExpand };
    this.hasUsedSlide = { ...data.hasUsedSlide };
    this.hasUsedShield = { ...data.hasUsedShield };
    this.hasUsedTeleport = { ...data.hasUsedTeleport };
    this.shieldedSquares = [...data.shieldedSquares];
    
    // Ensure arrays are properly sized
    const expectedSize = this.gridRows * 4;
    if (this.cells.length !== expectedSize) {
      console.warn("Resizing cells array to match grid");
      this.cells = this.cells.slice(0, expectedSize);
      while (this.cells.length < expectedSize) {
        this.cells.push(null);
      }
    }
    
    if (this.shieldedSquares.length !== expectedSize) {
      console.warn("Resizing shielded squares array to match grid");
      this.shieldedSquares = this.shieldedSquares.slice(0, expectedSize);
      while (this.shieldedSquares.length < expectedSize) {
        this.shieldedSquares.push(false);
      }
    }
    
    this.toaster("Game synchronized with opponent", "info");
    
  } catch (error) {
    console.error("Error handling game sync:", error);
    this.toaster("Failed to sync game state", "error");
  }
},
            // ADDED: Helper method to validate opponent power-up data
            isOpponentPowerUpValid(data) {
              // Basic validation for power-up messages
              if (!data.currentPlayer || !data.hasUsedSlide) return false;
              if (
                !Array.isArray(data.cells) ||
                data.cells.length !== this.gridRows * 4
              )
                return false;
              return true;
            },

sendGameSync() {
  if (!this.conn || !this.conn.open) return;
  
  this.conn.send({
    type: "gameSync",
    cells: [...this.cells],
    gridRows: this.gridRows,
    currentPlayer: this.currentPlayer,
    winner: this.winner,
    isDraw: this.isDraw,
    winningCombo: [...this.winningCombo],
    score: { ...this.score },
    moveHistory: [...this.moveHistory],
    hasUsedUndo: { ...this.hasUsedUndo },
    hasUsedRemove: { ...this.hasUsedRemove },
    hasUsedSwap: { ...this.hasUsedSwap },
    hasUsedExpand: { ...this.hasUsedExpand },
    hasUsedSlide: { ...this.hasUsedSlide },
    hasUsedShield: { ...this.hasUsedShield },
    hasUsedTeleport: { ...this.hasUsedTeleport },
    shieldedSquares: [...this.shieldedSquares],
  });
},

handleExpandData(data) {
  this.isExpanding = true;
  this.cells = [...data.cells];
  this.gridRows = data.gridRows;
  this.currentPlayer = data.currentPlayer;
  this.hasUsedExpand = { ...data.hasUsedExpand };
  this.squareEffects = Array(this.gridRows * 4).fill(false);
  this.shieldedSquares = [...(data.shieldedSquares || Array(this.gridRows * 4).fill(false))];

  setTimeout(() => {
    this.isExpanding = false;
  }, 800);

  this.toaster(`Opponent added row ${this.gridRows}! Now 4×${this.gridRows}`, "warning");
},


// Helper methods to handle different data types
handleMoveData(data) {
  // Validate move data
  if (this.isMyTurn) {
    console.warn("Received move when it's my turn - ignoring");
    return;
  }
  
  if (!Array.isArray(data.cells) || data.cells.length !== (data.gridRows || this.gridRows) * 4) {
    console.error("Invalid cells array in move data");
    return;
  }

  // Apply the move
  this.cells = [...data.cells];
  this.gridRows = data.gridRows || this.gridRows;
  this.currentPlayer = data.currentPlayer;
  this.winner = data.winner;
  this.isDraw = data.isDraw;
  this.winningCombo = [...(data.winningCombo || [])];
  this.score = { ...data.score };
  this.moveHistory = [...(data.moveHistory || [])];
  
  // Update power-up states
  this.hasUsedUndo = { ...data.hasUsedUndo };
  this.hasUsedRemove = { ...data.hasUsedRemove };
  this.hasUsedSwap = { ...(data.hasUsedSwap || { X: false, O: false }) };
  this.hasUsedExpand = { ...(data.hasUsedExpand || { X: false, O: false }) };
  this.hasUsedSlide = { ...(data.hasUsedSlide || { X: false, O: false }) };
  this.hasUsedShield = { ...(data.hasUsedShield || { X: false, O: false }) };
  this.hasUsedTeleport = { ...(data.hasUsedTeleport || { X: false, O: false }) };
  this.shieldedSquares = [...(data.shieldedSquares || Array(24).fill(false))];

  // Visual feedback
  if (this.moveHistory.length > 0) {
    const lastMove = this.moveHistory[this.moveHistory.length - 1];
    this.flashSquare(lastMove.index);
  }
  
  this.toaster("Opponent moved!", "info", 1500);
},

handleSlideData(data) {
  this.cells = [...data.cells];
  this.currentPlayer = data.currentPlayer;
  this.hasUsedSlide = { ...data.hasUsedSlide };
  this.shieldedSquares = [...(data.shieldedSquares || Array(24).fill(false))];
  this.winner = data.winner;
  this.isDraw = data.isDraw;
  this.winningCombo = [...(data.winningCombo || [])];
  this.toaster("Opponent used slide!", "info");
},

handleShieldData(data) {
  this.currentPlayer = data.currentPlayer;
  this.hasUsedShield = { ...data.hasUsedShield };
  this.shieldedSquares = [...data.shieldedSquares];
  this.toaster("Opponent used shield!", "success");
},

handleTeleportData(data) {
  this.cells = [...data.cells];
  this.currentPlayer = data.currentPlayer;
  this.hasUsedTeleport = { ...data.hasUsedTeleport };
  this.shieldedSquares = [...data.shieldedSquares];
  this.winner = data.winner;
  this.isDraw = data.isDraw;
  this.winningCombo = [...(data.winningCombo || [])];
  this.toaster("Opponent used teleport!", "warning");
},

handleUndoData(data) {
  this.cells = [...data.cells];
  this.currentPlayer = data.currentPlayer;
  this.winner = data.winner;
  this.isDraw = data.isDraw;
  this.winningCombo = [...(data.winningCombo || [])];
  this.moveHistory = [...(data.moveHistory || [])];
  this.hasUsedUndo = { ...data.hasUsedUndo };
  this.toaster("Opponent used undo!", "warning");
},

handleRemoveData(data) {
  this.cells = [...data.cells];
  this.currentPlayer = data.currentPlayer;
  this.hasUsedRemove = { ...data.hasUsedRemove };
  this.shieldedSquares = [...(data.shieldedSquares || Array(24).fill(false))];
  this.toaster("Opponent removed a piece!", "warning");
},

handleSwapData(data) {
  this.cells = [...data.cells];
  this.currentPlayer = data.currentPlayer;
  this.hasUsedSwap = { ...data.hasUsedSwap };
  this.shieldedSquares = [...(data.shieldedSquares || Array(24).fill(false))];
  this.winner = data.winner;
  this.isDraw = data.isDraw;
  this.winningCombo = [...(data.winningCombo || [])];
  this.toaster("Opponent used swap!", "info");
},

// Replace your setupConnection method with this simpler version:

setupConnection() {
  if (!this.conn) {
    console.error("setupConnection called but no connection exists");
    return;
  }

  console.log("Setting up connection handlers...");

  // Don't try to remove existing listeners - just add new ones
  // PeerJS 1.5.5 handles this internally

  this.conn.on("data", (data) => {
    try {
      console.log("Received data:", data);

      if (!data || typeof data !== "object") {
        console.error("Invalid data received:", data);
        return;
      }

      // Handle different message types
      switch (data.type) {
        case "move":
          // Validate move data
          if (this.isMyTurn) {
            console.warn("Received move when it's my turn - ignoring");
            return;
          }
          
          if (!Array.isArray(data.cells) || data.cells.length !== (data.gridRows || this.gridRows) * 4) {
            console.error("Invalid cells array in move data");
            return;
          }

          // Apply the move
          this.cells = [...data.cells];
          this.gridRows = data.gridRows || this.gridRows;
          this.currentPlayer = data.currentPlayer;
          this.winner = data.winner;
          this.isDraw = data.isDraw;
          this.winningCombo = [...(data.winningCombo || [])];
          this.score = { ...data.score };
          this.moveHistory = [...(data.moveHistory || [])];
          
          // Update power-up states
          this.hasUsedUndo = { ...data.hasUsedUndo };
          this.hasUsedRemove = { ...data.hasUsedRemove };
          this.hasUsedSwap = { ...(data.hasUsedSwap || { X: false, O: false }) };
          this.hasUsedExpand = { ...(data.hasUsedExpand || { X: false, O: false }) };
          this.hasUsedSlide = { ...(data.hasUsedSlide || { X: false, O: false }) };
          this.hasUsedShield = { ...(data.hasUsedShield || { X: false, O: false }) };
          this.hasUsedTeleport = { ...(data.hasUsedTeleport || { X: false, O: false }) };
          this.shieldedSquares = [...(data.shieldedSquares || Array(24).fill(false))];

          // Visual feedback
          if (this.moveHistory.length > 0) {
            const lastMove = this.moveHistory[this.moveHistory.length - 1];
            this.flashSquare(lastMove.index);
          }
          
          this.toaster("Opponent moved!", "info", 1500);
          break;

        case "slide":
          this.cells = [...data.cells];
          this.currentPlayer = data.currentPlayer;
          this.hasUsedSlide = { ...data.hasUsedSlide };
          this.shieldedSquares = [...(data.shieldedSquares || Array(24).fill(false))];
          this.winner = data.winner;
          this.isDraw = data.isDraw;
          this.winningCombo = [...(data.winningCombo || [])];
          this.toaster("Opponent used slide!", "info");
          break;

        case "shield":
          this.currentPlayer = data.currentPlayer;
          this.hasUsedShield = { ...data.hasUsedShield };
          this.shieldedSquares = [...data.shieldedSquares];
          this.toaster("Opponent used shield!", "success");
          break;

        case "teleport":
          this.cells = [...data.cells];
          this.currentPlayer = data.currentPlayer;
          this.hasUsedTeleport = { ...data.hasUsedTeleport };
          this.shieldedSquares = [...data.shieldedSquares];
          this.winner = data.winner;
          this.isDraw = data.isDraw;
          this.winningCombo = [...(data.winningCombo || [])];
          this.toaster("Opponent used teleport!", "warning");
          break;

        case "reset":
          this.resetGame(false);
          this.toaster("Opponent started a new game!", "info");
          break;

        case "undo":
          this.cells = [...data.cells];
          this.currentPlayer = data.currentPlayer;
          this.winner = data.winner;
          this.isDraw = data.isDraw;
          this.winningCombo = [...(data.winningCombo || [])];
          this.moveHistory = [...(data.moveHistory || [])];
          this.hasUsedUndo = { ...data.hasUsedUndo };
          this.toaster("Opponent used undo!", "warning");
          break;

        case "remove":
          this.cells = [...data.cells];
          this.currentPlayer = data.currentPlayer;
          this.hasUsedRemove = { ...data.hasUsedRemove };
          this.shieldedSquares = [...(data.shieldedSquares || Array(24).fill(false))];
          this.toaster("Opponent removed a piece!", "warning");
          break;

        case "swap":
          this.cells = [...data.cells];
          this.currentPlayer = data.currentPlayer;
          this.hasUsedSwap = { ...data.hasUsedSwap };
          this.shieldedSquares = [...(data.shieldedSquares || Array(24).fill(false))];
          this.winner = data.winner;
          this.isDraw = data.isDraw;
          this.winningCombo = [...(data.winningCombo || [])];
          this.toaster("Opponent used swap!", "info");
          break;

        case "expand":
          this.isExpanding = true;
          this.cells = [...data.cells];
          this.gridRows = data.gridRows;
          this.currentPlayer = data.currentPlayer;
          this.hasUsedExpand = { ...data.hasUsedExpand };
          this.squareEffects = Array(this.gridRows * 4).fill(false);
          this.shieldedSquares = [...(data.shieldedSquares || Array(this.gridRows * 4).fill(false))];

          setTimeout(() => {
            this.isExpanding = false;
          }, 800);

          this.toaster(`Opponent added row ${this.gridRows}! Now 4×${this.gridRows}`, "warning");
          break;

        default:
          console.warn("Unknown message type:", data.type);
      }
      
    } catch (error) {
      console.error("Error processing received data:", error);
      this.toaster("Error syncing with opponent", "error");
    }
  });

  this.conn.on("close", () => {
    console.log("Connection closed");
    this.toaster("Player disconnected", "error");
    this.conn = null;
    this.setGameMode("offline");
  });

  this.conn.on("error", (err) => {
    console.error("Connection error:", err);
    this.toaster(`Connection error: ${err.message || 'Unknown error'}`, "error");
    this.conn = null;
    
    if (this.peer) {
      this.peer.destroy();
      this.peer = null;
    }
  });
},
            getUrlParameter(name) {
              const params = new URLSearchParams(window.location.search);
              return params.get(name);
            },

       




// FIXED: Enhanced connectToPeer method with better timing and error handling
connectToPeer() {
  if (!this.peerIdToConnect.trim()) {
    this.toaster("Please enter a game ID", "error");
    return;
  }

  console.log("Attempting to connect to:", this.peerIdToConnect);
  
  this.setGameMode('multiplayer');
  this.isHost = false;
  
  // Clean up existing peer
  if (this.peer) {
    try {
      this.peer.destroy();
    } catch (error) {
      console.warn("Error destroying existing peer:", error);
    }
    this.peer = null;
  }

  // Create new peer for connecting
  this.peer = new Peer();

  // Set connection timeout
  const connectionTimeout = setTimeout(() => {
    console.log("Connection timeout");
    this.handleConnectionFailure("Connection timeout - unable to connect to game");
  }, 30000);

  this.peer.on("open", (myId) => {
    console.log("My peer ID:", myId);
          console.log("Attempting to connect to peer:", this.peerIdToConnect);
    // FIXED: Wait a bit for peer to be fully ready, then connect
    setTimeout(() => {
      console.log("Attempting to connect to peer:", this.peerIdToConnect);
      
      this.conn = this.peer.connect(this.peerIdToConnect);

      if (!this.conn) {
        console.error("Failed to create connection object");
        clearTimeout(connectionTimeout);
        this.handleConnectionFailure("Failed to create connection");
        return;
      }

      // FIXED: Set up connection handlers immediately after creating connection
      this.conn.on("open", () => {
        clearTimeout(connectionTimeout);
        console.log("Connection established successfully!");
        
        // Set up data handlers
        this.setupConnection();
        
        this.toaster("Connected to game! You are O, host is X.", "success");
        
        // Close modal
        const modal = document.getElementById("multiplayer-modal");
        if (modal && modal.open) {
          modal.close();
        }
      });

      this.conn.on("error", (err) => {
        clearTimeout(connectionTimeout);
        console.error("Connection error:", err);
        this.handleConnectionFailure("Failed to connect: " + (err.message || 'Unknown error'));
      });

      this.conn.on("close", () => {
        console.log("Connection closed");
        this.toaster("Connection closed by host", "warning");
        this.setGameMode("offline");
      });

      // Additional timeout for connection establishment
      setTimeout(() => {
        if (!this.conn || !this.conn.open) {
          clearTimeout(connectionTimeout);
          this.handleConnectionFailure("Connection failed to establish - game may not exist");
        }
      }, 20000);
      
    }, 2000); // Increased wait time for peer stability
  });

  this.peer.on("error", (err) => {
    clearTimeout(connectionTimeout);
    console.error("Peer error:", err);
    
    let errorMessage = "Connection failed";
    
    if (err.type === 'peer-unavailable') {
      errorMessage = "Game not found - please check the game ID";
    } else if (err.type === 'network') {
      errorMessage = "Network error - check your internet connection";
    } else if (err.type === 'disconnected') {
      errorMessage = "Disconnected from signaling server";
    } else {
      errorMessage = "Failed to connect: " + (err.message || 'Unknown error');
    }
    
    this.handleConnectionFailure(errorMessage);
  });
},






            copyPeerIdToClipboard() {
              const link = `${window.location.origin}${window.location.pathname}?gameId=${this.peerId}`;

              if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard
                  .writeText(link)
                  .then(() => {
                    this.toaster("Invite link copied to clipboard!", "success");
                  })
                  .catch((error) => {
                    this.handleError("Copy to clipboard", error);
                    this.fallbackCopyToClipboard(link);
                  });
              } else {
                this.fallbackCopyToClipboard(link);
              }
            },

            fallbackCopyToClipboard(text) {
              try {
                const textArea = document.createElement("textarea");
                textArea.value = text;
                textArea.style.position = "fixed";
                textArea.style.left = "-999999px";
                textArea.style.top = "-999999px";
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                document.execCommand("copy");
                textArea.remove();
                this.toaster("Invite link copied to clipboard!", "success");
              } catch (error) {
                this.toaster(
                  "Please copy this link manually: " + text,
                  "info",
                  8000,
                );
              }
            },

            makeMove(index) {
              if (!this.canMakeMove(index)) return; // <-- CHANGE THIS LINE

              console.log(
                "Making move at index:",
                index,
                "Current player:",
                this.currentPlayer,
              );

              this.moveHistory.push({ index, player: this.currentPlayer });
              this.cells[index] = this.currentPlayer;
              this.checkGameState();

              this.focusedCellIndex = index;

              if (!this.winner && !this.isDraw) {
                this.switchTurn();
              }

              this.announceGameState(
                `${this.getEmoji(this.currentPlayer)} placed in ${this.getCellAriaLabel(index, this.currentPlayer)}`,
              );

              // Only send multiplayer data if in multiplayer mode
              if (this.gameMode === "multiplayer" && this.conn) {
                // <-- ADD this condition check
                const moveData = {
                  type: "move",
                  cells: [...this.cells],
                  gridRows: this.gridRows,
                  currentPlayer: this.currentPlayer,
                  winner: this.winner,
                  isDraw: this.isDraw,
                  winningCombo: [...this.winningCombo],
                  score: { ...this.score },
                  moveHistory: [...this.moveHistory],
                  hasUsedUndo: { ...this.hasUsedUndo },
                  hasUsedRemove: { ...this.hasUsedRemove },
                  hasUsedSwap: { ...this.hasUsedSwap },
                  hasUsedExpand: { ...this.hasUsedExpand },
                  hasUsedSlide: { ...this.hasUsedSlide },
                  hasUsedShield: { ...this.hasUsedShield },
                  hasUsedTeleport: { ...this.hasUsedTeleport },
                  shieldedSquares: [...this.shieldedSquares],
                };
                console.log("Sending move data:", moveData);
                this.conn.send(moveData);
              }
            },

            checkGameState() {
              let wins = [];

              if (this.gridRows === 4) {
                wins = [
                  [0, 1, 2],
                  [1, 2, 3],
                  [4, 5, 6],
                  [5, 6, 7],
                  [8, 9, 10],
                  [9, 10, 11],
                  [12, 13, 14],
                  [13, 14, 15],
                  [0, 4, 8],
                  [4, 8, 12],
                  [1, 5, 9],
                  [5, 9, 13],
                  [2, 6, 10],
                  [6, 10, 14],
                  [3, 7, 11],
                  [7, 11, 15],
                  [0, 5, 10],
                  [1, 6, 11],
                  [4, 9, 14],
                  [5, 10, 15],
                  [2, 5, 8],
                  [3, 6, 9],
                  [6, 9, 12],
                  [7, 10, 13],
                ];
              } else {
                wins = [];

                for (let row = 0; row < this.gridRows; row++) {
                  for (let col = 0; col <= 1; col++) {
                    const start = row * 4 + col;
                    wins.push([start, start + 1, start + 2]);
                  }
                }

                for (let col = 0; col < 4; col++) {
                  for (let row = 0; row <= this.gridRows - 3; row++) {
                    const start = row * 4 + col;
                    wins.push([start, start + 4, start + 8]);
                  }
                }

                for (let row = 0; row <= this.gridRows - 3; row++) {
                  for (let col = 0; col <= 1; col++) {
                    const start = row * 4 + col;
                    wins.push([start, start + 5, start + 10]);
                  }
                }

                for (let row = 0; row <= this.gridRows - 3; row++) {
                  for (let col = 2; col <= 3; col++) {
                    const start = row * 4 + col;
                    wins.push([start, start + 3, start + 6]);
                  }
                }
              }

              for (let combo of wins) {
                const [a, b, c] = combo;
                if (
                  this.cells[a] &&
                  this.cells[a] === this.cells[b] &&
                  this.cells[a] === this.cells[c]
                ) {
                  this.winner = this.cells[a];
                  this.winningCombo = combo;
                  this.score[this.winner]++;
                  this.toaster(
                    `🏆 ${this.getEmoji(this.winner)} wins!`,
                    "success",
                    5000,
                  );
                  this.celebrationFireworks();
                  this.playSound("clapping");
                  this.announceGameState(
                    `Game over! ${this.getEmoji(this.winner)} wins!`,
                  );
                  return;
                }
              }

              if (!this.cells.includes(null)) {
                this.isDraw = true;
                this.toaster("🤝 It's a draw!", "warning", 4000);
                this.announceGameState("Game over! It's a draw!");
              }
            },

            celebrationFireworks() {
              if (typeof confetti === "undefined") return;

              const duration = 3000;
              const animationEnd = Date.now() + duration;
              const defaults = {
                startVelocity: 30,
                spread: 360,
                ticks: 60,
                zIndex: 0,
              };

              function randomInRange(min, max) {
                return Math.random() * (max - min) + min;
              }

              const interval = setInterval(() => {
                const timeLeft = animationEnd - Date.now();

                if (timeLeft <= 0) {
                  return clearInterval(interval);
                }

                const particleCount = 50 * (timeLeft / duration);
                confetti({
                  ...defaults,
                  particleCount,
                  origin: {
                    x: randomInRange(0.1, 0.3),
                    y: Math.random() - 0.2,
                  },
                });
                confetti({
                  ...defaults,
                  particleCount,
                  origin: {
                    x: randomInRange(0.7, 0.9),
                    y: Math.random() - 0.2,
                  },
                });
              }, 250);
            },

            resetGame(sync = true) {
              const gameBoard = document.querySelector(".grid");
              if (gameBoard) gameBoard.classList.add("fade-out");

              setTimeout(() => {
                this.cells = Array(16).fill(null);
                this.gridRows = 4;
                this.isExpanding = false;
                this.moveHistory = [];
                this.currentPlayer = "X";
                this.winner = null;
                this.isDraw = false;
                this.winningCombo = [];
                this.hasUsedUndo = { X: false, O: false };
                this.hasUsedRemove = { X: false, O: false };
                this.hasUsedSwap = { X: false, O: false };
                this.hasUsedExpand = { X: false, O: false };
                this.hasUsedSlide = { X: false, O: false };
                this.hasUsedShield = { X: false, O: false };
                this.hasUsedTeleport = { X: false, O: false };
                this.swapSelection = [];
                this.slideSelection = [];
                this.teleportSelection = [];
                this.slideMode = "select";
                this.shieldedSquares = Array(24).fill(false);
                this.squareEffects = Array(24).fill(false);
                this.focusedCellIndex = 0;

                if (gameBoard) gameBoard.classList.remove("fade-out");

                this.toaster("New game started!", "info");
                //   this.playSound("theme");
                setTimeout(() => {
                  this.announceGameState(
                    `${this.getEmoji(this.currentPlayer)} goes first!`,
                  );
                }, 500);

                if (sync && this.conn && this.conn.open) {
                  this.conn.send({ type: "reset" });
                }
              }, 300);
            },

            playSound(soundName) {
              const audio = new Audio(`/assets/sounds/${soundName}.mp3`);
              audio.volume = 0.3;
              audio.play().catch((e) => console.warn("Sound play failed:", e));
            },
          },

          mounted() {
            try {
              document.getElementById("app-loading").style.display = "none";
              document.getElementById("app").style.display = "block";

              this.setupKeyboardNavigation();
              //  this.playSound("theme");

              try {
                const saved = localStorage.getItem("tictactoe-score");
                if (saved) {
                  this.score = JSON.parse(saved);
                }
              } catch (error) {
                console.warn("Failed to load saved score:", error);
                this.score = { X: 0, O: 0 };
              }

              const gameId = this.getUrlParameter("gameId");
              console.log("Game ID from URL:", gameId);
              if (gameId) {
                this.peerIdToConnect = gameId;
                this.toaster("Connecting to game...", "info", 3000);
                try {
                  this.connectToPeer();
                } catch (error) {
                  this.handleConnectionFailure(
                    "Failed to connect to game",
                    error,
                  );
                }
              }

              const urlParams = new URLSearchParams(window.location.search);
              const mode = urlParams.get("mode");
              const view = urlParams.get("view");

              if (mode === "multiplayer") {
                this.showMultiplayerModal();
              } else if (view === "rules") {
                this.showAboutModal();
              }

              setTimeout(() => {
                if (!this.winner && !this.isDraw) {
                  this.announceGameState(
                    `${this.getEmoji(this.currentPlayer)} goes first!`,
                  );
                }
              }, 1000);
            } catch (error) {
              console.error("Error during app initialization:", error);
              showErrorBoundary();
            }
          },

          beforeUnmount() {
            // MISSING: Clear AI timeouts
            if (this.aiMoveTimeout) {
              clearTimeout(this.aiMoveTimeout);
            }

            document.removeEventListener("keydown", this.handleKeyDown);

            if (this.peer) {
              this.peer.destroy();
            }

            // MISSING: Close any open connections
            if (this.conn) {
              this.conn.close();
            }

            // MISSING: Clear any pending animation frames
            if (this.animationFrame) {
              cancelAnimationFrame(this.animationFrame);
            }
          },
        });

        app.mount("#app");
      }
    </script>
  </body>
</html>
